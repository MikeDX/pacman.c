//------------------------------------------------------------------------------
//  pacman.c
//------------------------------------------------------------------------------
#include "sokol_app.h"
#include "sokol_gfx.h"
#include "sokol_audio.h"
#include "sokol_time.h"
#include "sokol_glue.h"
#include <assert.h>
#include <string.h> // memset()

#define DBG_SKIP_INTRO      (1)     // set to (1) to skip intro
#define DBG_SKIP_PRELUDE    (1)     // set to (1) to skip game prelude
#define DBG_MARKERS         (1)     // set to (1) to show debug markers

// various constants
enum {
    TILE_WIDTH          = 8,
    TILE_HEIGHT         = 8,
    SPRITE_WIDTH        = 16,
    SPRITE_HEIGHT       = 16,
    DISPLAY_TILES_X     = 28,
    DISPLAY_TILES_Y     = 36, 
    DISPLAY_PIXELS_X    = DISPLAY_TILES_X * TILE_WIDTH,
    DISPLAY_PIXELS_Y    = DISPLAY_TILES_Y * TILE_HEIGHT,
    NUM_SPRITES         = 8,
    NUM_DEBUG_MARKERS   = 16,
    TILE_TEXTURE_WIDTH  = 256 * TILE_WIDTH,
    TILE_TEXTURE_HEIGHT = TILE_HEIGHT + SPRITE_HEIGHT,  
    MAX_VERTICES        = ((DISPLAY_TILES_X * DISPLAY_TILES_Y) + NUM_SPRITES + NUM_DEBUG_MARKERS) * 6,
    FADE_TICKS          = 30,       // duration of fade-in/out
    NUM_LIVES           = 3,
    NUM_STATUS_FRUITS   = 7,    // max number of displayed fruits at bottom right
    NUM_DOTS            = 244,  // 240 small dots + 4 pills
    NUM_PILLS           = 4,    // number of energizer pills on playfield
    ANTEPORTAS_X        = 14*TILE_WIDTH,  // pixel position of the house enter/leave point
    ANTEPORTAS_Y        = 14*TILE_HEIGHT + TILE_HEIGHT/2
};

// common tile codes
enum {
    TILE_SPACE          = 0x40,
    TILE_DOT            = 0x10,
    TILE_PILL           = 0x14,
    TILE_GHOST          = 0xB0,
    TILE_LIFE           = 0x20,      // 0x20..0x23
    TILE_CHERRIES       = 0x90,      // 0x90..0x93
    TILE_STRAWBERRY     = 0x94,      // 0x94..0x97
    TILE_PEACH          = 0x98,      // 0x98..0x9B
    TILE_BELL           = 0x9C,      // 0x9C..0x9F
    TILE_APPLE          = 0xA0,      // 0xA0..0xA3
    TILE_GRAPES         = 0xA4,      // 0xA4..0xA7
    TILE_GALAXIAN       = 0xA8,      // 0xA8..0xAB
    TILE_KEY            = 0xAC,      // 0xAC..0xAF
    TILE_DOOR           = 0xCF,      // the ghost-house door
};

// common color codes
enum {
    COLOR_BLANK         = 0x00,
    COLOR_DEFAULT       = 0x0F,
    COLOR_DOT           = 0x10,
    COLOR_PACMAN        = 0x09,
    COLOR_BLINKY        = 0x01,
    COLOR_PINKY         = 0x03,
    COLOR_INKY          = 0x05,
    COLOR_CLYDE         = 0x07,
    COLOR_FRIGHTENED    = 0x11,
    COLOR_FRIGHTENED_BLINKING = 0x12,
    COLOR_CHERRIES      = 0x14,
    COLOR_STRAWBERRY    = 0x0F, // FIXME: same as COLOR_DEFAULT?
    COLOR_PEACH         = 0x15,
    COLOR_BELL          = 0x16,
    COLOR_APPLE         = 0x14,
    COLOR_GRAPES        = 0x17,
    COLOR_GALAXIAN      = 0x09,
    COLOR_KEY           = 0x16,
};

// the top-level game states (intro => game => hiscore)
typedef enum {
    GAMESTATE_INTRO,
    GAMESTATE_GAME,
    GAMESTATE_HISCORE,
} gamestate_t;

// directions NOTE: bit0==0: horizontal movement, bit0==1: vertical movement
typedef enum {
    DIR_RIGHT,  // 000
    DIR_DOWN,   // 001
    DIR_LEFT,   // 010
    DIR_UP,     // 011
    NUM_DIRS
} dir_t;

// fruit types
typedef enum {
    FRUITTYPE_NONE,
    FRUITTYPE_CHERRIES,
    FRUITTYPE_STRAWBERRY,
    FRUITTYPE_PEACH,
    FRUITTYPE_APPLE,
    FRUITTYPE_GRAPES,
    FRUITTYPE_GALAXIAN,
    FRUITTYPE_BELL,
    FRUITTYPE_KEY,
    NUM_FRUITTYPES
} fruit_t;

// sprite indices
typedef enum {
    SPRITE_BLINKY,
    SPRITE_PINKY,
    SPRITE_INKY,
    SPRITE_CLYDE,
    SPRITE_PACMAN,
    SPRITE_FRUIT,
} sprite_index_t;

// ghost types
typedef enum {
    GHOSTTYPE_BLINKY,
    GHOSTTYPE_PINKY,
    GHOSTTYPE_INKY,
    GHOSTTYPE_CLYDE,
    NUM_GHOSTS
} ghosttype_t;

// ghost AI states
typedef enum {
    GHOSTSTATE_NONE,
    GHOSTSTATE_CHASE,
    GHOSTSTATE_SCATTER,
    GHOSTSTATE_FRIGHTENED,
    GHOSTSTATE_EYES,
    GHOSTSTATE_HOUSE,
    GHOSTSTATE_LEAVEHOUSE,
    GHOSTSTATE_ENTERHOUSE
} ghoststate_t;

// a timer holds a specific game-tick when an action should be started
typedef struct {
    uint32_t tick;
} timer_t;

// a 2D integer vector (used both for pixel- and tile-coordinates)
typedef struct {
    int16_t x;
    int16_t y;
} int2_t;

// common state for pacman and ghosts
typedef struct {
    dir_t dir;
    int2_t pos;             // position of sprite midpoint in pixel coords
    uint32_t anim_tick;     // incremented when actor moved in current tick
} actor_t;

// ghost state
typedef struct {
    actor_t actor;
    ghosttype_t type;
    dir_t next_dir;
    int2_t target_pos;
    ghoststate_t state;
    timer_t frightened;
    uint8_t dot_counter;    // the ghost's personal dot counter for the ghost-house-logic
} ghost_t;

// pacman state
typedef struct {
    actor_t actor;
} pacman_t;

// the tile- and sprite-renderer's vertex structure
typedef struct {
    float x, y;         // screen coords [0..1] as FLOAT2
    float u, v;         // tile texture coords
    uint32_t attr;      // x: color code
} vertex_t;

// sprite state
typedef struct {
    bool enabled;
    uint8_t tile, color;    // sprite-tile number (0..63), color code
    bool flipx, flipy;
    int2_t pos;
} sprite_t;

// debug visualization markers
typedef struct {
    bool enabled;
    uint8_t tile, color;    // tile and color code
    int2_t tile_pos;
} debugmarker_t;

// all state is in a single nested struct
static struct {

    uint32_t tick;          // the central game tick, this drives the whole game
    gamestate_t gamestate;  // the current gamestate (intro => game => hiscore)

    // intro state
    struct {
        timer_t started;
        timer_t chase;
    } intro;

    // hiscore state
    struct {
        timer_t started;
    } hiscore;

    // game state
    struct {
        uint32_t xorshift;      // current xorshift random-number-generator state
        timer_t started;
        timer_t prelude_started;
        timer_t round_started;
        timer_t last_dot_eaten;     // last time Pacman ate a dot
        timer_t last_pill_eaten;    // last time Pacman ate a pill
        timer_t force_leave_house;  // starts when a dot is eaten
        bool frozen;            // if true the game is currently 'frozen'
        uint32_t score;         // score / 10
        uint32_t hiscore;       // hiscore / 10
        uint8_t num_lives;
        bool dot_counter_active;    // set to true when Pacman loses a life
        uint8_t dot_counter;        // the global dot counter for the ghost-house-logic
        ghost_t ghost[NUM_GHOSTS];
        pacman_t pacman;
        fruit_t fruit[NUM_STATUS_FRUITS];
    } game;

    // the current input state
    struct {
        bool enabled;
        bool up;
        bool down;
        bool left;
        bool right;
        bool esc;       // FIXME: only for debugging
        bool anykey;
    } input;

    // the gfx subsystem implements a simple tile+sprite renderer
    struct {
        // fade-in/out triggers
        timer_t fadein;
        timer_t fadeout;

        // the 36x28 tile framebuffer
        uint8_t video_ram[DISPLAY_TILES_Y][DISPLAY_TILES_X]; // tile codes
        uint8_t color_ram[DISPLAY_TILES_Y][DISPLAY_TILES_X]; // color codes

        // up to 8 sprites
        sprite_t sprite[NUM_SPRITES];

        // up to 16 debug markers
        debugmarker_t debug_marker[NUM_DEBUG_MARKERS];

        // current fade value (0: no fade, 255: fully opaque)
        uint8_t fade;

        // sokol-gfx resources
        sg_pass_action pass_action;
        struct {
            sg_buffer vbuf;
            sg_image tile_img;
            sg_image palette_img;
            sg_image render_target;
            sg_pipeline pip;
            sg_pass pass;
        } offscreen;
        struct {
            sg_buffer quad_vbuf;
            sg_pipeline pip;
        } display;

        // intermediate vertex buffer for tile- and sprite-rendering
        int num_vertices;
        vertex_t vertices[MAX_VERTICES];

        // scratch-buffer for tile-decoding (only happens once)
        uint8_t tile_pixels[TILE_TEXTURE_HEIGHT][TILE_TEXTURE_WIDTH];

        // scratch buffer for the color palette
        uint32_t color_palette[256];
    } gfx;
} state;

// forward declarations
static void init(void);
static void frame(void);
static void cleanup(void);
static void input(const sapp_event*);

static void start(timer_t* t);

static void pacman_tick(void);
static void intro_tick(void);
static void game_tick(void);
static void hiscore_tick(void);

static void input_enable(void);
static void input_disable(void);

static void gfx_init(void);
static void gfx_fade(void);
static void gfx_draw(void);

static uint8_t rom_tiles[4096];
static uint8_t rom_sprites[4096];
static uint8_t rom_hwcolors[32];
static uint8_t rom_palette[256];

/*== APPLICATION ENTRY AND CALLBACKS =========================================*/
sapp_desc sokol_main(int argc, char* argv[]) {
    return (sapp_desc) {
        .init_cb = init,
        .frame_cb = frame,
        .cleanup_cb = cleanup,
        .event_cb = input,
        .width = DISPLAY_TILES_X * TILE_WIDTH * 2,
        .height = DISPLAY_TILES_Y * TILE_HEIGHT * 2,
        .window_title = "pacman.c"
    };
}

static void init(void) {
    // setup sokol libs
    sg_setup(&(sg_desc){
        .context = sapp_sgcontext()
    });
    stm_setup();
    saudio_setup(&(saudio_desc){ 0 });

    // initialize subsystems
    gfx_init();

    // start into intro screen
    #if DBG_SKIP_INTRO
        start(&state.game.started);
    #else
        start(&state.intro.started);
    #endif
}

static void frame(void) {
    // FIXME: decouple pacman_tick() from refresh rate
    pacman_tick();
    gfx_draw();
}

static void input(const sapp_event* ev) {
    if (state.input.enabled) {
        if ((ev->type == SAPP_EVENTTYPE_KEY_DOWN) || (ev->type == SAPP_EVENTTYPE_KEY_UP)) {
            bool btn_down = ev->type == SAPP_EVENTTYPE_KEY_DOWN;
            switch (ev->key_code) {
                case SAPP_KEYCODE_UP:
                case SAPP_KEYCODE_W:
                    state.input.up = state.input.anykey = btn_down;
                    break;
                case SAPP_KEYCODE_DOWN:
                case SAPP_KEYCODE_S:
                    state.input.down = state.input.anykey = btn_down;
                    break;
                case SAPP_KEYCODE_LEFT:
                case SAPP_KEYCODE_A:
                    state.input.left = state.input.anykey = btn_down;
                    break;
                case SAPP_KEYCODE_RIGHT:
                case SAPP_KEYCODE_D:
                    state.input.right = state.input.anykey = btn_down;
                    break;
                case SAPP_KEYCODE_ESCAPE:
                    state.input.esc = state.input.anykey = btn_down;
                    break;
                default:
                    state.input.anykey = btn_down;
                    break;
            }
        }
    }
}

static void cleanup(void) {
    sg_shutdown();
    saudio_shutdown();
}

/*== GRAB BAG OF HELPER FUNCTIONS ============================================*/

// xorshift random number generator
static uint32_t xorshift32(void) {
    uint32_t x = state.game.xorshift;
    x ^= x<<13;
    x ^= x>>17;
    x ^= x<<5;
    return state.game.xorshift = x;
}

// set a timer to the next game tick
static void start(timer_t* t) {
    t->tick = state.tick + 1;
}

// set a timer to a future tick
static void start_after(timer_t* t, uint32_t ticks) {
    t->tick = state.tick + ticks;
}

// deactivate a timer
static void disable(timer_t* t) {
    t->tick = 0xFFFFFFFF;
}

// return a disabled timer
static timer_t disabled_timer(void) {
    return (timer_t) { .tick = 0xFFFFFFFF };
}

// check if a timer is triggered
static bool now(timer_t t) {
    return t.tick == state.tick;
}

// return the number of ticks since a timer was triggered
static uint32_t since(timer_t t) {
    if (state.tick >= t.tick) {
        return state.tick - t.tick;
    }
    else {
        return 0xFFFFFFFF;
    }
}

// check if a timer is between begin and end tick
static bool between(timer_t t, uint32_t begin, uint32_t end) {
    assert((begin >= 0) && (begin < end));
    uint32_t ticks = since(t);
    return (ticks >= begin) && (ticks < end);
}

// check if a timer was triggered N ticks ago
static bool after(timer_t t, uint32_t ticks) {
    return since(t) == ticks;
}

// clear input state and disable input
static void input_disable(void) {
    memset(&state.input, 0, sizeof(state.input));
}

// enable input again
static void input_enable(void) {
    state.input.enabled = true;
}

// get the current input as dir_t
static dir_t input_dir(dir_t default_dir) {
    if (state.input.up) {
        return DIR_UP;
    }
    else if (state.input.down) {
        return DIR_DOWN;
    }
    else if (state.input.right) {
        return DIR_RIGHT;
    }
    else if (state.input.left) {
        return DIR_LEFT;
    }
    else {
        return default_dir;
    }
}

// shortcut to create an int2_t
static int2_t i2(int16_t x, int16_t y) {
    return (int2_t) { x, y };
}

// add two int2_t
static int2_t add_i2(int2_t v0, int2_t v1) {
    return (int2_t) { v0.x+v1.x, v0.y+v1.y };
}

// subtract two int2_t
static int2_t sub_i2(int2_t v0, int2_t v1) {
    return (int2_t) { v0.x-v1.x, v0.y-v1.y };
}

// multiply int2_t with scalar
static int2_t mul_i2(int2_t v, int16_t s) {
    return (int2_t) { v.x*s, v.y*s };
}

// squared-distance between two int2_t
static int32_t squared_distance_i2(int2_t v0, int2_t v1) {
    int2_t d = { v1.x - v0.x, v1.y - v0.y };
    return d.x * d.x + d.y * d.y;
}

// convert an actor pos (origin at center) to sprite pos (origin top left)
static int2_t actor_to_sprite_pos(int2_t pos) {
    return i2(pos.x - SPRITE_WIDTH/2, pos.y - SPRITE_HEIGHT/2);
}

// compute the distance of a pixel coordinate to the next tile midpoint
int2_t dist_to_tile_mid(int2_t pos) {
    return i2((TILE_WIDTH/2) - pos.x % TILE_WIDTH, (TILE_HEIGHT/2) - pos.y % TILE_HEIGHT);
}

// clear tile buffer
static void vid_clear(uint8_t tile_code, uint8_t color_code) {
    memset(&state.gfx.video_ram, tile_code, sizeof(state.gfx.video_ram));
    memset(&state.gfx.color_ram, color_code, sizeof(state.gfx.color_ram));
}

// check if a tile position is valid
static bool valid_tile_pos(int2_t tile_pos) {
    return ((tile_pos.x >= 0) && (tile_pos.x < DISPLAY_TILES_X) && (tile_pos.y >= 0) && (tile_pos.y < DISPLAY_TILES_Y));
}

// put a color into the color buffer
static void vid_color(int2_t tile_pos, uint8_t color_code) {
    assert(valid_tile_pos(tile_pos));
    state.gfx.color_ram[tile_pos.y][tile_pos.x] = color_code;
}

// put a tile into the tile buffer
static void vid_tile(int2_t tile_pos, uint8_t tile_code) {
    assert(valid_tile_pos(tile_pos));
    state.gfx.video_ram[tile_pos.y][tile_pos.x] = tile_code;
}

// put a colored tile into the tile buffer
static void vid_color_tile(int2_t tile_pos, uint8_t color_code, uint8_t tile_code) {
    assert(valid_tile_pos(tile_pos));
    state.gfx.video_ram[tile_pos.y][tile_pos.x] = tile_code;
    state.gfx.color_ram[tile_pos.y][tile_pos.x] = color_code;
}

// translate ASCII char into "NAMCO char"
static char conv_char(char c) {
    switch (c) {
        case ' ':   c = 0x40; break;
        case '/':   c = 58; break;
        case '-':   c = 59; break;
        case '\"':  c = 38; break;
        case '!':   c = 'Z'+1; break;
        default: break;
    }
    return c;
}

// put char with color into tile buffer
static void vid_color_char(int2_t tile_pos, uint8_t color_code, char chr) {
    assert(valid_tile_pos(tile_pos));
    state.gfx.video_ram[tile_pos.y][tile_pos.x] = conv_char(chr);
    state.gfx.color_ram[tile_pos.y][tile_pos.x] = color_code;
}

// put char without color into tile buffer
static void vid_char(int2_t tile_pos, char chr) {
    assert(valid_tile_pos(tile_pos));
    state.gfx.video_ram[tile_pos.y][tile_pos.x] = conv_char(chr);
}

// put colored text into the tile buffer
static void vid_color_text(int2_t tile_pos, uint8_t color_code, const char* text) {
    assert(valid_tile_pos(tile_pos));
    uint8_t chr;
    while ((chr = (uint8_t) *text++)) {
        if (tile_pos.x < DISPLAY_TILES_X) {
            vid_color_char(tile_pos, color_code, chr);
            tile_pos.x++;
        }
        else {
            break;
        }
    }
}

// put text without color into the tile buffer
static void vid_text(int2_t tile_pos, const char* text) {
    assert(valid_tile_pos(tile_pos));
    uint8_t chr;
    while ((chr = (uint8_t) *text++)) {
        if (tile_pos.x < DISPLAY_TILES_X) {
            vid_char(tile_pos, chr);
            tile_pos.x++;
        }
        else {
            break;
        }
    }
}

/* print score number into tile buffer from right to left(!),
    scores are /10, the last printed number is always 0, 
    a zero-score will print as '00' (this is the same as on
    the Pacman arcade machine)
*/
static void vid_color_score(int2_t tile_pos, uint8_t color_code, uint32_t score) {
    vid_color_char(tile_pos, color_code, '0');
    tile_pos.x--;
    for (int digit = 0; digit < 8; digit++) {
        char chr = (score % 10) + '0';
        if (valid_tile_pos(tile_pos)) {
            vid_color_char(tile_pos, color_code, chr);
            tile_pos.x--;
            score /= 10;
            if (0 == score) {
                break;
            }
        }
    }
}

/* draw a tile-quad arranged as:
    |t+1|t+0|
    |t+3|t+2|
*/
static void vid_draw_tile_quad(int2_t tile_pos, uint8_t color_code, uint8_t tile_code) {
    for (int yy=0; yy<2; yy++) {
        for (int xx=0; xx<2; xx++) {
            uint8_t t = tile_code + yy*2 + (1-xx);
            vid_color_tile(i2(xx + tile_pos.x, yy + tile_pos.y), color_code, t);
        }
    }
}


// disable and reset all sprites
static void spr_clear(void) {
    memset(&state.gfx.sprite, 0, sizeof(state.gfx.sprite));
}

// set sprite to animated pacman
static void spr_anim_pacman(int index, dir_t dir, uint32_t tick) {
    assert((index >= 0) && (index < NUM_SPRITES));
    // animation frames for horizontal and vertical movement
    static const uint8_t tiles[2][4] = {
        { 44, 46, 48, 46 }, // horizontal (needs flipx)
        { 45, 47, 48, 47 }  // vertical (needs flipy)
    };
    sprite_t* spr = &state.gfx.sprite[index];
    uint32_t phase = (tick / 4) & 3;
    spr->tile  = tiles[dir & 1][phase];
    spr->color = COLOR_PACMAN;
    spr->flipx = (dir == DIR_LEFT);
    spr->flipy = (dir == DIR_UP);
}

// set sprite to animated ghost
static void spr_anim_ghost(int index, dir_t dir, uint32_t tick) {
    assert((index >= 0) && (index < NUM_SPRITES));
    assert((dir >= 0) && (dir < NUM_DIRS));
    static const uint8_t tiles[4][2]  = {
        { 32, 33 }, // right
        { 34, 35 }, // down
        { 36, 37 }, // left
        { 38, 39 }, // up
    };
    uint32_t phase = (tick / 8) & 1;
    sprite_t* spr = &state.gfx.sprite[index];
    spr->tile = tiles[dir][phase];
    spr->color = COLOR_BLINKY + 2*index;
    spr->flipx = false;
    spr->flipy = false;
}

// set sprite to animated, frightened ghost
static void spr_anim_ghost_frightened(int index, uint32_t tick) {
    assert((index >= 0) && (index < NUM_SPRITES));
    static const uint8_t tiles[4] = { 28, 29 };
    uint32_t phase = (tick / 4) & 1;
    sprite_t* spr = &state.gfx.sprite[index];
    spr->tile = tiles[phase];
    // FIXME: replace hardwired time offset
    if (tick > 4*60) {
        // towards end of frightening period, start blinking
        spr->color = (tick & 0x10) ? COLOR_FRIGHTENED : COLOR_FRIGHTENED_BLINKING;
    }
    else {
        spr->color = COLOR_FRIGHTENED;
    }
    spr->flipx = false;
    spr->flipy = false;
}

// convert pixel position to tile position
static int2_t pixel_to_tile_pos(int2_t pix_pos) {
    return i2(pix_pos.x / TILE_WIDTH, pix_pos.y / TILE_HEIGHT);
}

// clamp tile pos to valid playfield coords
static int2_t clamped_tile_pos(int2_t tile_pos) {
    int2_t res = tile_pos;
    if (res.x < 0) {
        res.x = 0;
    }
    else if (res.x >= DISPLAY_TILES_X) {
        res.x = DISPLAY_TILES_X - 1;
    }
    if (res.y < 3) {
        res.y = 3;
    }
    else if (res.y >= (DISPLAY_TILES_Y-2)) {
        res.y = DISPLAY_TILES_Y - 3;
    }
    return res;
}

// convert a direction to a movement vector
static int2_t dir_to_vec(dir_t dir) {
    assert((dir >= 0) && (dir < NUM_DIRS));
    static const int2_t dir_map[NUM_DIRS] = { { +1, 0 }, { 0, +1 }, { -1, 0 }, { 0, -1 } };
    return dir_map[dir];
}

// return the reverse dir for a direction
static dir_t reverse_dir(dir_t dir) {
    switch (dir) {
        case DIR_RIGHT: return DIR_LEFT;
        case DIR_DOWN:  return DIR_UP;
        case DIR_LEFT:  return DIR_RIGHT;
        default:        return DIR_DOWN;
    }
}

// return tile code at tile position
static uint8_t tile_code_at(int2_t tile_pos) {
    assert((tile_pos.x >= 0) && (tile_pos.x < DISPLAY_TILES_X));
    assert((tile_pos.y >= 0) && (tile_pos.y < DISPLAY_TILES_Y));
    return state.gfx.video_ram[tile_pos.y][tile_pos.x];
}

// check if a tile position contains a blocking tile
static bool is_blocking_tile(int2_t tile_pos) {
    const uint8_t tile_code = tile_code_at(tile_pos);
    switch (tile_code) {
        case TILE_DOT:
        case TILE_PILL:
        case TILE_SPACE:
            return false;
        default:
            return true;
    }
}

// check if a tile position contains a dot tile
static bool is_dot(int2_t tile_pos) {
    return tile_code_at(tile_pos) == TILE_DOT;
}

// check if a tile position contains a pill tile
static bool is_pill(int2_t tile_pos) {
    return tile_code_at(tile_pos) == TILE_PILL;
}

// check if a tile position is in the teleport tunnel
static bool is_tunnel(int2_t tile_pos) {
    return (tile_pos.y == 17) && (tile_pos.x <= 5) && (tile_pos.x >= 22);
}

// test if movement from a pixel position in a wanted direction is possible 
bool can_move(int2_t pos, dir_t wanted_dir, bool allow_cornering) {
    const int2_t dir_vec = dir_to_vec(wanted_dir);
    const int2_t dist_mid = dist_to_tile_mid(pos);
    
    // distance to midpoint in move direction and perpendicular direction
    int16_t move_dist_mid, perp_dist_mid;
    if (dir_vec.y != 0) {
        move_dist_mid = dist_mid.y;
        perp_dist_mid = dist_mid.x;
    }
    else {
        move_dist_mid = dist_mid.x;
        perp_dist_mid = dist_mid.y;
    }
    
    // look one tile ahead in movement direction
    const int2_t tile_pos = pixel_to_tile_pos(pos);
    const int2_t check_pos = clamped_tile_pos(i2(tile_pos.x + dir_vec.x, tile_pos.y + dir_vec.y));
    const bool is_blocked = is_blocking_tile(check_pos);
    if ((!allow_cornering && (0 != perp_dist_mid)) || (is_blocked && (0 == move_dist_mid))) {
        // way is blocked
        return false;
    }
    else {
        // way is free
        return true;
    }
}

// compute a new pixel position along a direction (without blocking check!)
static int2_t move(int2_t pos, dir_t dir, bool allow_cornering) {
    const int2_t dir_vec = dir_to_vec(dir);
    pos = add_i2(pos, dir_vec);

    // if cornering is allowed, drag the position towards the center-line
    if (allow_cornering) {
        const int2_t dist_mid = dist_to_tile_mid(pos);
        if (dir_vec.x != 0) {
            if (dist_mid.y < 0)      { pos.y--; }
            else if (dist_mid.y > 0) { pos.y++; }
        }
        else if (dir_vec.y != 0) {
            if (dist_mid.x < 0)      { pos.x--; }
            else if (dist_mid.x > 0) { pos.x++; }
        }
    }
    
    // wrap around in the teleport-tunnel
    if (pos.x < 0) {
        pos.x = DISPLAY_PIXELS_X - 1;
    }
    else if (pos.x > DISPLAY_PIXELS_X) {
        pos.x = 0;
    }
    return pos;
}

// disable and reset all debug markers
static void dbg_clear(void) {
    memset(&state.gfx.debug_marker, 0, sizeof(state.gfx.debug_marker));
}

// set a debug marker
static void dbg_marker(int index, int2_t tile_pos, uint8_t tile_code, uint8_t color_code) {
    assert((index >= 0) && (index < NUM_DEBUG_MARKERS));
    state.gfx.debug_marker[index] = (debugmarker_t) {
        .enabled = true,
        .tile = tile_code,
        .color = color_code,
        .tile_pos = clamped_tile_pos(tile_pos)
    };
}

/*== TOP-LEVEL GAME CODE =====================================================*/
static void pacman_tick(void) {
    state.tick++;

    // check for game state change
    if (now(state.intro.started)) {
        state.gamestate = GAMESTATE_INTRO;
    }
    if (now(state.game.started)) {
        state.gamestate = GAMESTATE_GAME;
    }
    if (now(state.hiscore.started)) {
        state.gamestate = GAMESTATE_HISCORE;
    }

    // call the top-level game state update function
    switch (state.gamestate) {
        case GAMESTATE_INTRO:
            intro_tick();
            break;
        case GAMESTATE_GAME:
            game_tick();
            break;
        case GAMESTATE_HISCORE:
            hiscore_tick();
            break;
    }
}

/*== INTRO GAMESTATE CODE ====================================================*/

static void intro_tick(void) {

    // on intro-state enter, enable input and draw any initial text
    if (now(state.intro.started)) {
        start(&state.gfx.fadein);
        input_enable();
        vid_clear(TILE_SPACE, COLOR_DEFAULT);
        vid_text(i2(3,0),  "1UP   HIGH SCORE   2UP");
        vid_color_score(i2(6,1), COLOR_DEFAULT, 0);
        if (state.game.hiscore > 0) {
            vid_color_score(i2(16,1), COLOR_DEFAULT, state.game.hiscore);
        }
        vid_text(i2(7,5),  "CHARACTER / NICKNAME");
        vid_text(i2(3,35), "CREDIT  0");
        spr_clear();
        disable(&state.intro.chase);
    }

    // draw the animated 'ghost image.. name.. nickname' lines
    uint32_t delay = 30;
    const char* names[] = { "-SHADOW", "-SPEEDY", "-BASHFUL", "-POKEY" };
    const char* nicknames[] = { "BLINKY", "PINKY", "INKY", "CLYDE" };
    for (int i = 0; i < 4; i++) {
        const uint8_t color = 2*i + 1;
        const uint8_t y = 3*i + 6;
        // 2*3 ghost image created from tiles (no sprite!)
        delay += 30;
        if (after(state.intro.started, delay)) {
            vid_color_tile(i2(4,y+0), color, TILE_GHOST+0); vid_color_tile(i2(5,y+0), color, TILE_GHOST+1);
            vid_color_tile(i2(4,y+1), color, TILE_GHOST+2); vid_color_tile(i2(5,y+1), color, TILE_GHOST+3);
            vid_color_tile(i2(4,y+2), color, TILE_GHOST+4); vid_color_tile(i2(5,y+2), color, TILE_GHOST+5);
        }
        // after 1 second, the name of the ghost
        delay += 60;
        if (after(state.intro.started, delay)) {
            vid_color_text(i2(7,y+1), color, names[i]);
        }
        // after 0.5 seconds, the nickname of the ghost
        delay += 30;
        if (after(state.intro.started, delay)) {
            vid_color_text(i2(17,y+1), color, nicknames[i]);
        }
    }

    // . 10 PTS
    // O 50 PTS
    delay += 60;
    if (after(state.intro.started, delay)) {
        vid_color_tile(i2(10,24), COLOR_DOT, TILE_DOT);
        vid_text(i2(12,24), "10 \x5D\x5E\x5F");
        vid_color_tile(i2(10,26), COLOR_DOT, TILE_PILL);
        vid_text(i2(12,26), "50 \x5D\x5E\x5F");
    }

    // blinking "press any key" text
    delay += 60;
    if (since(state.intro.started) > delay) {
        if (since(state.intro.started) & 0x20) {
            vid_color_text(i2(3,31), 3, "                       ");
        }
        else {
            vid_color_text(i2(3,31), 3, "PRESS ANY KEY TO START!");
        }
    }

    // FIXME: rewrite this with "gameplay code"
    // the animated chase sequence
    delay += 60;
    if (after(state.intro.started, delay)) {
        start(&state.intro.chase);
        vid_color_tile(i2(4,20), COLOR_DOT, TILE_PILL);
        int16_t x = 224;
        state.gfx.sprite[SPRITE_BLINKY] = (sprite_t) { .enabled = true, .pos = { x+20, 156 }, .color = COLOR_BLINKY };
        state.gfx.sprite[SPRITE_PINKY]  = (sprite_t) { .enabled = true, .pos = { x+36, 156 }, .color = COLOR_PINKY };
        state.gfx.sprite[SPRITE_INKY]   = (sprite_t) { .enabled = true, .pos = { x+52, 156 }, .color = COLOR_INKY };
        state.gfx.sprite[SPRITE_CLYDE]  = (sprite_t) { .enabled = true, .pos = { x+68, 156 }, .color = COLOR_CLYDE };
        state.gfx.sprite[SPRITE_PACMAN] = (sprite_t) { .enabled = true, .pos = { x,    156 }, .color = COLOR_PACMAN };
    }
    // ghosts are chasing pacman...
    if (between(state.intro.chase, 1, 200)) {
        for (int i = 0; i < 5; i++) {
            if (i == SPRITE_PACMAN) { spr_anim_pacman(i, DIR_LEFT, state.tick); }
            else                    { spr_anim_ghost(i, DIR_LEFT, state.tick); }
            state.gfx.sprite[i].pos.x--;
        }
    }
    // pacman is chasing and eating ghosts
    if (between(state.intro.chase, 210, 500)) {
        for (int i = 0; i < 5; i++) {
            if (i == SPRITE_PACMAN) {
                spr_anim_pacman(i, DIR_RIGHT, state.tick);
                state.gfx.sprite[i].pos.x++;
            }
            else {
                spr_anim_ghost_frightened(i, state.tick);
                state.gfx.sprite[i].color = COLOR_FRIGHTENED;
                if (state.tick & 1) {
                    state.gfx.sprite[i].pos.x++;
                }
            }
        }
    }

    // if a key is pressed, advance to game state
    if (state.input.anykey) {
        input_disable();
        start(&state.gfx.fadeout);
        start_after(&state.game.started, FADE_TICKS);
    }
}

/*== HISCORE GAMESTATE CODE ==================================================*/
static void hiscore_tick(void) {
    if (now(state.hiscore.started)) {
        start(&state.gfx.fadein);
        spr_clear();
        input_enable();
        vid_clear(TILE_SPACE, COLOR_DEFAULT);
        vid_text(i2(7,16), "HISCORE TODO!");
    }
    if (state.input.anykey) {
        input_disable();
        start(&state.gfx.fadeout);
        start_after(&state.intro.started, FADE_TICKS);
    }
}

/*== ACTUAL GAMESTATE CODE ===================================================*/

// one-time init at start of game state
static void game_init(void) {
    input_enable();
    state.game.frozen = true;
    state.game.num_lives = NUM_LIVES;
    state.game.score = 0;
    for (int i = 0; i < NUM_STATUS_FRUITS; i++) {
        state.game.fruit[i] = (i==0) ? FRUITTYPE_CHERRIES:FRUITTYPE_NONE;
    }
}

// setup state at start of a game round
static void game_round_init(void) {
    spr_clear();
    state.game.xorshift = 0x12345678;
    state.game.dot_counter_active = false;
    state.game.dot_counter = 0;
    disable(&state.game.last_dot_eaten);
    disable(&state.game.last_pill_eaten);
    disable(&state.game.force_leave_house);

    // draw the playfield
    {
        vid_clear(TILE_SPACE, COLOR_DOT);
        vid_color_text(i2(9,0), COLOR_DEFAULT, "HIGH SCORE");

        // decode the playfield from an ASCII map into tiles codes
        static const char* tiles =
           //0123456789012345678901234567
            "0UUUUUUUUUUUU45UUUUUUUUUUUU1" // 3
            "L............rl............R" // 4
            "L.ebbf.ebbbf.rl.ebbbf.ebbf.R" // 5
            "LPr  l.r   l.rl.r   l.r  lPR" // 6
            "L.guuh.guuuh.gh.guuuh.guuh.R" // 7
            "L..........................R" // 8
            "L.ebbf.ef.ebbbbbbf.ef.ebbf.R" // 9
            "L.guuh.rl.guuyxuuh.rl.guuh.R" // 10
            "L......rl....rl....rl......R" // 11
            "2BBBBf.rzbbf rl ebbwl.eBBBB3" // 12
            "     L.rxuuh gh guuyl.R     " // 13
            "     L.rl          rl.R     " // 14
            "     L.rl mjs--tjn rl.R     " // 15
            "UUUUUh.gh i      q gh.gUUUUU" // 16
            "      .   i      q   .      " // 17
            "BBBBBf.ef i      q ef.eBBBBB" // 18
            "     L.rl okkkkkkp rl.R     " // 19
            "     L.rl          rl.R     " // 20
            "     L.rl ebbbbbbf rl.R     " // 21
            "0UUUUh.gh guuyxuuh gh.gUUUU1" // 22
            "L............rl............R" // 23
            "L.ebbf.ebbbf.rl.ebbbf.ebbf.R" // 24
            "L.guyl.guuuh.gh.guuuh.rxuh.R" // 25
            "LP..rl.......  .......rl..PR" // 26
            "6bf.rl.ef.ebbbbbbf.ef.rl.eb8" // 27
            "7uh.gh.rl.guuyxuuh.rl.gh.gu9" // 28
            "L......rl....rl....rl......R" // 29
            "L.ebbbbwzbbf.rl.ebbwzbbbbf.R" // 30
            "L.guuuuuuuuh.gh.guuuuuuuuh.R" // 31
            "L..........................R" // 32
            "2BBBBBBBBBBBBBBBBBBBBBBBBBB3"; // 33
           //0123456789012345678901234567
        uint8_t t[128];
        for (int i = 0; i < 128; i++) { t[i]=TILE_DOT; }
        t[' ']=0x40; t['0']=0xD1; t['1']=0xD0; t['2']=0xD5; t['3']=0xD4; t['4']=0xFB;
        t['5']=0xFA; t['6']=0xD7; t['7']=0xD9; t['8']=0xD6; t['9']=0xD8; t['U']=0xDB;
        t['L']=0xD3; t['R']=0xD2; t['B']=0xDC; t['b']=0xDF; t['e']=0xE7; t['f']=0xE6;
        t['g']=0xEB; t['h']=0xEA; t['l']=0xE8; t['r']=0xE9; t['u']=0xE5; t['w']=0xF5;
        t['x']=0xF2; t['y']=0xF3; t['z']=0xF4; t['m']=0xED; t['n']=0xEC; t['o']=0xEF;
        t['p']=0xEE; t['j']=0xDD; t['i']=0xD2; t['k']=0xDB; t['q']=0xD3; t['s']=0xF1;
        t['t']=0xF0; t['-']=TILE_DOOR; t['P']=TILE_PILL;
        for (int y = 3, i = 0; y <= 33; y++) {
            for (int x = 0; x < 28; x++, i++) {
                state.gfx.video_ram[y][x] = t[tiles[i] & 127];
            }
        }
        // patch colors
        vid_color(i2(13,15), 0x18); vid_color(i2(14,15), 0x18); // ghost house gate
        // PLAYER ONE READY!
        vid_color_text(i2(9,14), 0x5, "PLAYER ONE");
        vid_color_text(i2(11, 20), 0x9, "READY!");
    }

    // Pacman starts running to the left
    state.game.pacman = (pacman_t) {
        .actor = {
            .dir = DIR_LEFT, 
            .pos = { .x = 14 * 8, 26 * 8 + 4 },
        },
    };
    state.gfx.sprite[SPRITE_PACMAN] = (sprite_t) { .enabled=false, .color=COLOR_PACMAN };

    // Blinky starts outside the ghost house, looking to the left, and in scatter mode
    state.game.ghost[GHOSTTYPE_BLINKY] = (ghost_t) {
        .actor = {
            .dir = DIR_LEFT,
            .pos = { .x = 14*8, .y = 14*8+4 },
        },
        .type = GHOSTTYPE_BLINKY,
        .next_dir = DIR_LEFT,
        .state = GHOSTSTATE_SCATTER,
        .frightened = disabled_timer(),
        .dot_counter = 0
    };
    state.gfx.sprite[SPRITE_BLINKY] = (sprite_t) { .enabled = false, .color = COLOR_BLINKY };

    // Pinky starts in the middle slot of the ghost house, moving down
    state.game.ghost[GHOSTTYPE_PINKY] = (ghost_t) {
        .actor = {
            .dir = DIR_DOWN,
            .pos = { .x = 14*8, .y = 17*8+4 },
        },
        .type = GHOSTTYPE_PINKY,
        .next_dir = DIR_DOWN,
        .state = GHOSTSTATE_HOUSE,
        .frightened = disabled_timer(),
        .dot_counter = 0,
    };
    state.gfx.sprite[SPRITE_PINKY] = (sprite_t) { .enabled = false, .color = COLOR_PINKY };

    // Inky starts in the left slot of the ghost house moving up
    state.game.ghost[GHOSTTYPE_INKY] = (ghost_t) {
        .actor = {
            .dir = DIR_UP,
            .pos = { .x = 12*8, .y = 17*8+4 },
        },
        .type = GHOSTTYPE_INKY,
        .next_dir = DIR_UP,
        .state = GHOSTSTATE_HOUSE,
        .frightened = disabled_timer(),
        // FIXME: needs to be adjusted by current round!
        .dot_counter = 30,
    };
    state.gfx.sprite[SPRITE_INKY] = (sprite_t) { .enabled = false, .color = COLOR_INKY };

    // Clyde starts in the right slot of the ghost house, moving up
    state.game.ghost[GHOSTTYPE_CLYDE] = (ghost_t) {
        .actor = {
            .dir = DIR_UP,
            .pos = { .x = 16*8, .y=17*8+4 },
        },
        .type = GHOSTTYPE_CLYDE,
        .next_dir = DIR_UP, 
        .state = GHOSTSTATE_HOUSE,
        .frightened = disabled_timer(),
        // FIXME: needs to be adjusted by current round!
        .dot_counter = 60,
    };
    state.gfx.sprite[SPRITE_CLYDE] = (sprite_t) { .enabled = false, .color = COLOR_CLYDE };
}

static void game_update_tiles(void) {
    // score and hiscore
    vid_color_score(i2(6,1), COLOR_DEFAULT, state.game.score);
    if (state.game.hiscore > 0) {
        vid_color_score(i2(16,1), COLOR_DEFAULT, state.game.hiscore);
    }

    // update the energizer pill colors (blinking/non-blinking)
    static const int2_t pill_pos[NUM_PILLS] = { { 1, 6 }, { 26, 6 }, { 1, 26 }, { 26, 26 } };
    for (int i = 0; i < NUM_PILLS; i++) {
        if (state.game.frozen) {
            vid_color(pill_pos[i], COLOR_DOT);
        }
        else {
            vid_color(pill_pos[i], (state.tick & 0x8) ? 0x10:0);
        }
    }

    // lives at bottom left screen
    for (int i = 0; i < NUM_LIVES; i++) {
        uint8_t color = (i < state.game.num_lives) ? COLOR_PACMAN : 0;
        vid_draw_tile_quad(i2(2+2*i,34), color, TILE_LIFE);
    }
    // draw fruit table
    uint8_t fruit_tiles_colors[NUM_FRUITTYPES][2] = {
        { 0, 0 },   // FRUIT_NONE
        { TILE_CHERRIES, COLOR_CHERRIES },
        { TILE_STRAWBERRY, COLOR_STRAWBERRY },
        { TILE_PEACH, COLOR_PEACH },
        { TILE_APPLE, COLOR_APPLE },
        { TILE_GRAPES, COLOR_GRAPES },
        { TILE_GALAXIAN, COLOR_GALAXIAN },
        { TILE_BELL, COLOR_BELL, },
        { TILE_KEY, COLOR_KEY }
    };
    for (int i = 0; i < NUM_STATUS_FRUITS; i++) {
        uint8_t tile_code = fruit_tiles_colors[state.game.fruit[i]][0];
        uint8_t color_code = fruit_tiles_colors[state.game.fruit[i]][1];
        vid_draw_tile_quad(i2(24-2*i,34), color_code, tile_code);
    }
}

static void game_update_sprites(void) {
    // update Pacman sprite
    if (state.gfx.sprite[SPRITE_PACMAN].enabled) {
        const actor_t* actor = &state.game.pacman.actor;
        state.gfx.sprite[SPRITE_PACMAN].pos = actor_to_sprite_pos(actor->pos);
        if (state.game.frozen) {
            state.gfx.sprite[SPRITE_PACMAN].tile = 48;
        }
        else {
            spr_anim_pacman(SPRITE_PACMAN, actor->dir, actor->anim_tick);
        }
    }

    // update ghost sprites
    for (int i = 0; i < NUM_GHOSTS; i++) {
        if (state.gfx.sprite[i].enabled) {
            const ghost_t* ghost = &state.game.ghost[i];
            state.gfx.sprite[i].pos = actor_to_sprite_pos(ghost->actor.pos);
            switch (ghost->state) {
                case GHOSTSTATE_EYES:
                    // FIXME!
                    spr_anim_ghost_frightened(i, ghost->actor.anim_tick);
                    break;
                case GHOSTSTATE_FRIGHTENED:
                    // FIXME: ghost show the frightened visualization also
                    // in the 'house-states'
                    spr_anim_ghost_frightened(i, since(ghost->frightened));
                    break;
                default:
                    // NOTE: ghost always indicate early what direction they're going:
                    spr_anim_ghost(i, ghost->next_dir, ghost->actor.anim_tick);
                    break;
            }
        }
    }

    // FIXME: update fruit sprite
}

// return true if Pacman should move in this tick
static bool game_pacman_should_move(void) {
    if (now(state.game.last_dot_eaten)) {
        // eating a dot causes Pacman to stop for 1 tick
        return false;
    }
    else if (since(state.game.last_pill_eaten) < 3) {
        // eating an energizer pill causes Pacman to stop for 3 ticks
        return false;
    }
    else {
        // FIXME: hardcode regular speed to 80% for now, this
        // needs to be adjusted based on the game round
        // FIXME: during frighten phase, Pacman also speeds
        // up during levels 1..4
        return 0 != (state.tick % 5);
    }
}

/*
    return number of pixels a ghost should move this tick (in eyes-state,
    ghost moves faster than one pixel per tick
*/
static int game_ghost_speed(const ghost_t* ghost) {
    assert(ghost);
    // FIXME: speeds are also level-dependent!
    switch (ghost->state) {
        case GHOSTSTATE_HOUSE:
        case GHOSTSTATE_LEAVEHOUSE:
        case GHOSTSTATE_ENTERHOUSE:
            // inside house at half speed (estimated)
            return state.tick & 1;
        case GHOSTSTATE_FRIGHTENED:
            // move at 50% speed when frightened
            return state.tick & 1;
        case GHOSTSTATE_EYES:
            // estimated 1.5x when hollow, Pacman Dossier is silent on this
            return (state.tick & 1) ? 1 : 2;
        default:
            // in tunnel, move at 40%, otherwise 75%
            if (is_tunnel(pixel_to_tile_pos(ghost->actor.pos))) {
                return ((state.tick * 2) % 4) ? 1 : 0;
            }
            else {
                return (state.tick % 4) ? 1 : 0;
            }
    }
}

// return the current global scatter or chase phase
static ghoststate_t game_scatter_chase_phase(void) {
    uint32_t t = since(state.game.round_started);
    if (t < 7*60)       return GHOSTSTATE_SCATTER;
    else if (t < 27*60) return GHOSTSTATE_CHASE;
    else if (t < 34*60) return GHOSTSTATE_SCATTER;
    else if (t < 54*60) return GHOSTSTATE_CHASE;
    else if (t < 59*60) return GHOSTSTATE_SCATTER;
    else if (t < 79*60) return GHOSTSTATE_CHASE;
    else if (t < 84*60) return GHOSTSTATE_SCATTER;
    else return GHOSTSTATE_CHASE;
}

// switches a ghost into new state if needed
static void game_update_ghost_state(ghost_t* ghost) {
    assert(ghost);
    ghoststate_t new_state = ghost->state;
    switch (ghost->state) {
        case GHOSTSTATE_EYES:
            // FIXME
            break;
        case GHOSTSTATE_ENTERHOUSE:
            // FIXME
            break;
        case GHOSTSTATE_HOUSE:
            if (after(state.game.force_leave_house, 4*60)) {
                // if Pacman hasn't eaten dots for 4 seconds, the next ghost
                // is forced out of the house
                // FIXME: time is reduced to 3 seconds after round 5
                new_state = GHOSTSTATE_LEAVEHOUSE;
                start(&state.game.force_leave_house);
            }
            else if (state.game.dot_counter_active) {
                // if Pacman has lost a live this round, the global dot counter is used
                if ((ghost->type == GHOSTTYPE_PINKY) && (state.game.dot_counter == 7)) {
                    new_state = GHOSTSTATE_LEAVEHOUSE;
                }
                else if ((ghost->type == GHOSTTYPE_INKY) && (state.game.dot_counter == 17)) {
                    new_state = GHOSTSTATE_LEAVEHOUSE;
                }
                else if ((ghost->type == GHOSTTYPE_CLYDE) && (state.game.dot_counter == 32)) {
                    new_state = GHOSTSTATE_LEAVEHOUSE;
                    // NOTE that global dot counter is deactivated if (and only if) Clyde
                    // is in the house and the dot counter reaches 32
                    state.game.dot_counter_active = false;
                }
            }
            else if (ghost->dot_counter == 0) {
                // in the normal case, check the ghost's personal dot counter
                new_state = GHOSTSTATE_LEAVEHOUSE;
            }
            break;
        case GHOSTSTATE_LEAVEHOUSE:
            if (ghost->actor.pos.y == ANTEPORTAS_Y) {
                new_state = GHOSTSTATE_SCATTER;
            }
            break;
        case GHOSTSTATE_FRIGHTENED:
            // FIXME: length of frightened period is variable
            if (since(ghost->frightened) >  6*60) {
                new_state = game_scatter_chase_phase();
            }
            break;
        default:
            // FIXME: length of frightened period is variable
            if (since(ghost->frightened) < 6*60) {
                new_state = GHOSTSTATE_FRIGHTENED;
            }
            else {
                new_state = game_scatter_chase_phase();
            }
    }
    // handle state transitions
    if (new_state != ghost->state) {
        switch (ghost->state) {
            case GHOSTSTATE_LEAVEHOUSE:
                // after leaving the ghost house, head to the left
                ghost->next_dir = ghost->actor.dir = DIR_LEFT;
                break;
            case GHOSTSTATE_ENTERHOUSE:
                // after entering the ghost house, start moving up and down
                ghost->next_dir = ghost->actor.dir = DIR_DOWN;
                break;
            case GHOSTSTATE_FRIGHTENED:
                // don't reverse direction when leaving frightened state
                break;
            default:
                // all other state transition cause a reverse of direction
                ghost->next_dir = reverse_dir(ghost->actor.dir);
                break;
        }
        ghost->state = new_state;
    }
}

static void game_update_ghost_target(ghost_t* ghost) {
    assert(ghost);
    int2_t pos = ghost->target_pos;
    static const int2_t scatter_targets[NUM_GHOSTS] = { { 25, 0 }, { 2, 0 }, { 27, 34 }, { 0, 34 } };
    switch (ghost->state) {
        case GHOSTSTATE_SCATTER:
            assert((ghost->type >= 0) && (ghost->type < NUM_GHOSTS));
            pos = scatter_targets[ghost->type];
            break;
        case GHOSTSTATE_CHASE:
            {
                const actor_t* pm = &state.game.pacman.actor;
                const int2_t pm_pos = pixel_to_tile_pos(pm->pos);
                const int2_t pm_dir = dir_to_vec(pm->dir);
                switch (ghost->type) {
                    case GHOSTTYPE_BLINKY:
                        // Blinky directly chases Pacman
                        pos = pm_pos;
                        break;
                    case GHOSTTYPE_PINKY:
                        // Pinky target is 4 tiles ahead of Pacman
                        // FIXME: does not reproduce 'diagonal overflow'
                        pos = add_i2(pm_pos, mul_i2(pm_dir, 4));
                        break;
                    case GHOSTTYPE_INKY:
                        // Inky targets an extrapolated pos along a line two tiles
                        // ahead of Pacman through Blinky
                        {
                            const int2_t blinky_pos = pixel_to_tile_pos(state.game.ghost[GHOSTTYPE_BLINKY].actor.pos);
                            const int2_t p = add_i2(pm_pos, mul_i2(pm_dir, 2));
                            const int2_t d = sub_i2(p, blinky_pos);
                            pos = add_i2(blinky_pos, mul_i2(d, 2));
                        }
                        break;
                    case GHOSTTYPE_CLYDE:
                        // if Clyde is far away from Pacman, he chases Pacman, 
                        // but if close he moves towards the scatter target
                        if (squared_distance_i2(pixel_to_tile_pos(ghost->actor.pos), pm_pos) > 64) {
                            pos = pm_pos;
                        }
                        else {
                            pos = scatter_targets[GHOSTTYPE_CLYDE];
                        }
                        break;
                    default:
                        break;
                }
            }
            break;
        case GHOSTSTATE_FRIGHTENED:
            /* in frightened state just select a random target position
                this has the effect that ghosts in frightened state 
                move in a random direction at each intersection
            */
            pos = i2(xorshift32() % DISPLAY_TILES_X, xorshift32() % DISPLAY_TILES_Y);
            break;
        case GHOSTSTATE_EYES:
            // move towards the ghost house door
            pos = i2(13, 15);
            break;
        default:
            break;
    }
    ghost->target_pos = pos;
}

/* compute the next ghost direction, return true if resulting movement
    should always happen regardless of current ghost position or blocking
    tiles (this special case is used for movement inside the ghost house.
*/
static bool game_update_ghost_dir(ghost_t* ghost) {
    assert(ghost);
    // inside ghost-house, just move up and down
    if (ghost->state == GHOSTSTATE_HOUSE) {
        if (ghost->actor.pos.y <= 17*TILE_HEIGHT) {
            ghost->next_dir = DIR_DOWN;
        }
        else if (ghost->actor.pos.y >= 18*TILE_HEIGHT) {
            ghost->next_dir = DIR_UP;
        }
        ghost->actor.dir = ghost->next_dir;
        // force movement
        return true;
    }
    // navigate the ghost out of the ghost house
    else if (ghost->state == GHOSTSTATE_LEAVEHOUSE) {
        const int2_t pos = ghost->actor.pos;
        if (pos.x == ANTEPORTAS_X) {
            if (pos.y > ANTEPORTAS_Y) {
                ghost->next_dir = DIR_UP;
            }
        }
        else {
            const int16_t mid_y = 17*TILE_HEIGHT + TILE_HEIGHT/2;
            if (pos.y > mid_y) {
                ghost->next_dir = DIR_UP;
            }
            else if (pos.y < mid_y) {
                ghost->next_dir = DIR_DOWN;
            }
            else {
                ghost->next_dir = (pos.x > ANTEPORTAS_X) ? DIR_LEFT:DIR_RIGHT;
            }
        }
        ghost->actor.dir = ghost->next_dir;
        return true;
    }
    else if (ghost->state == GHOSTSTATE_ENTERHOUSE) {
        return true;
    }
    // scatter/chase/frightened: just head towards the current target point
    else {
        // only compute new direction when currently at midpoint of tile
        const int2_t dist_to_mid = dist_to_tile_mid(ghost->actor.pos);
        if ((dist_to_mid.x == 0) && (dist_to_mid.y == 0)) {
            // new direction is the previously computed next-direction
            ghost->actor.dir = ghost->next_dir;

            // compute new next-direction
            const int2_t dir_vec = dir_to_vec(ghost->actor.dir);
            const int2_t lookahead_pos = add_i2(pixel_to_tile_pos(ghost->actor.pos), dir_vec);

            // try each direction and take the one that moves closest to the target
            const dir_t dirs[NUM_DIRS] = { DIR_UP, DIR_LEFT, DIR_DOWN, DIR_RIGHT };
            int min_dist = 100000;
            int dist = 0;
            for (int i = 0; i < NUM_DIRS; i++) {
                const dir_t dir = dirs[i];
                const dir_t revdir = reverse_dir(dir);
                const int2_t test_pos = clamped_tile_pos(add_i2(lookahead_pos, dir_to_vec(dir)));
                if ((revdir != ghost->actor.dir) && !is_blocking_tile(test_pos)) {
                    if ((dist = squared_distance_i2(test_pos, ghost->target_pos)) < min_dist) {
                        min_dist = dist;
                        ghost->next_dir = dir;
                    }
                }
            }
        }
        return false;
    }
}

/* Update the dot counters used to decide whether ghosts must leave the house.
    
    This is called each time Pacman eats a dot.

    Each ghost has a dot limit which is reset at the start of a round. Each time
    Pacman eats a dot, the highest priority ghost in the ghost house counts
    down its dot counter.

    When the dot personal counter reaches zero the ghost leaves the house
    and the next highest-priority dot counter starts counting.

    If a life is lost, the personal dot counters are deactivated and instead
    a global dot counter is used.

    If pacman doesn't eat dots for a while, the next ghost is forced out of the
    house using a timer.
*/
static void game_update_dot_counters(void) {
    // if a life was lost round, use the global dot counter (this will)
    // be deactivated again after all ghosts left the house
    if (state.game.dot_counter_active) {
        state.game.dot_counter++;
    }
    else {
        for (int i = 0; i < NUM_GHOSTS; i++) {
            if (state.game.ghost[i].dot_counter > 0) {
                state.game.ghost[i].dot_counter--;
                break;
            }
        }
    }
}

static void game_update_actors(void) {
    // FIXME: check if the next ghost is forced out of the house

    // Pacman "AI"
    // FIXME: for now hardwire to 80% speed (skip every 5th frame), this needs to be looked up in a table
    if (game_pacman_should_move()) {
        // move Pacman with cornering allowed
        actor_t* actor = &state.game.pacman.actor;
        const dir_t wanted_dir = input_dir(actor->dir);
        const bool allow_cornering = true;
        // look ahead to check if the wanted direction is blocked
        if (can_move(actor->pos, wanted_dir, allow_cornering)) {
            actor->dir = wanted_dir;
        }
        // move into the current direction
        if (can_move(actor->pos, actor->dir, allow_cornering)) {
            actor->pos = move(actor->pos, actor->dir, allow_cornering);
            actor->anim_tick++;
        }
        // eat dot or energizer pill?
        const int2_t tile_pos = pixel_to_tile_pos(actor->pos);
        if (is_dot(tile_pos)) {
            vid_tile(tile_pos, TILE_SPACE);
            state.game.score += 1;
            start(&state.game.last_dot_eaten);
            start(&state.game.force_leave_house);
            game_update_dot_counters();
        }
        if (is_pill(tile_pos)) {
            vid_tile(tile_pos, TILE_SPACE);
            state.game.score += 5;
            start(&state.game.last_pill_eaten);
            for (int i = 0; i < NUM_GHOSTS; i++) {
                start(&state.game.ghost[i].frightened);
            }
        }
    }

    // Ghost "AIs"
    for (int ghost_index = 0; ghost_index < NUM_GHOSTS; ghost_index++) {
        ghost_t* ghost = &state.game.ghost[ghost_index];
        // handle ghost-state transitions
        game_update_ghost_state(ghost);
        const int num_move_ticks = game_ghost_speed(ghost);
        game_update_ghost_target(ghost);
        for (int i = 0; i < num_move_ticks; i++) {
            bool force_move = game_update_ghost_dir(ghost);
            actor_t* actor = &ghost->actor;
            const bool allow_cornering = false;
            if (force_move || can_move(actor->pos, actor->dir, allow_cornering)) {
                actor->pos = move(actor->pos, actor->dir, allow_cornering);
                actor->anim_tick++;
            }
        }
    }
}

static void game_tick(void) {
    // initialize game state
    if (now(state.game.started)) {
        start(&state.gfx.fadein);
        start(&state.game.prelude_started);
        game_init();
    }
    // initialize new round
    if (now(state.game.prelude_started)) {
        game_round_init();
    }
    // debug: speed the prelude up 
    #if DBG_SKIP_PRELUDE
        const int ticks_per_sec = 1;
    #else
        const int ticks_per_sec = 60;
    #endif
    // after 3 seconds, make actors visible, remove "PLAYER ONE"
    if (after(state.game.prelude_started, 3*ticks_per_sec)) {
        vid_color_text(i2(9,14), 0x10, "          ");
        for (int i = 0; i < NUM_GHOSTS+1; i++) {
            state.gfx.sprite[i].enabled = true;
        }
        if (NUM_LIVES == state.game.num_lives) {
            state.game.num_lives = NUM_LIVES - 1;
        }
    }
    // after 5 seconds, the interactive game starts
    if (after(state.game.prelude_started, 5*ticks_per_sec)) {
        start(&state.game.round_started);
    }
    if (now(state.game.round_started)) {
        state.game.frozen = false;
        // clear the 'READY!' message
        vid_color_text(i2(11,20), 0x10, "      ");
    }

    if (!state.game.frozen) {
        game_update_actors();
    }
    game_update_tiles();
    game_update_sprites();

    // update hiscore
    if (state.game.score > state.game.hiscore) {
        state.game.hiscore = state.game.score;
    }

    if (state.input.esc) {
        input_disable();
        start(&state.gfx.fadeout);
        start_after(&state.hiscore.started, FADE_TICKS);
    }

    #if DBG_MARKERS
    // visualize current ghost targets
    for (int i = 0; i < NUM_GHOSTS; i++) {
        const ghost_t* ghost = &state.game.ghost[i];
        uint8_t tile = 'X';
        switch (ghost->state) {
            case GHOSTSTATE_NONE:       tile = 'N'; break;
            case GHOSTSTATE_CHASE:      tile = 'C'; break;
            case GHOSTSTATE_SCATTER:    tile = 'S'; break;
            case GHOSTSTATE_FRIGHTENED: tile = 'F'; break;
            case GHOSTSTATE_EYES:       tile = 'E'; break;
            case GHOSTSTATE_HOUSE:      tile = 'H'; break;
            case GHOSTSTATE_LEAVEHOUSE: tile = 'L'; break;
            case GHOSTSTATE_ENTERHOUSE: tile = 'E'; break;
        }
        dbg_marker(i, state.game.ghost[i].target_pos, tile, COLOR_BLINKY+2*i);
    }
    #endif
}

/*== GFX SUBSYSTEM ===========================================================*/

/* create all sokol-gfx resources */
static void gfx_create_resources(void) {
    // pass action for clearing the background to black
    state.gfx.pass_action = (sg_pass_action) {
        .colors[0] = { .action = SG_ACTION_CLEAR, .val = { 0.0f, 0.0f, 0.0f, 1.0f } }
    };

    // create a dynamic vertex buffer for the tile and sprite quads
    state.gfx.offscreen.vbuf = sg_make_buffer(&(sg_buffer_desc){
        .type = SG_BUFFERTYPE_VERTEXBUFFER,
        .usage = SG_USAGE_STREAM,
        .size = sizeof(state.gfx.vertices),
    });

    // create a simple quad vertex buffer for rendering the offscreen render target to the display
    float quad_verts[]= { 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 1.0f };
    state.gfx.display.quad_vbuf = sg_make_buffer(&(sg_buffer_desc){
        .size = sizeof(quad_verts),
        .content = quad_verts,
    });

    // shader sources for all platforms (FIXME: should we use precompiled shader blobs instead?)
    const char* offscreen_vs_src = 0;
    const char* offscreen_fs_src = 0;
    const char* display_vs_src = 0;
    const char* display_fs_src = 0;
    switch (sg_query_backend()) {
        case SG_BACKEND_METAL_MACOS:
            offscreen_vs_src = 
                "#include <metal_stdlib>\n"
                "using namespace metal;\n"
                "struct vs_in {\n"
                "  float4 pos [[attribute(0)]];\n"
                "  float2 uv [[attribute(1)]];\n"
                "  float4 data [[attribute(2)]];\n"
                "};\n"
                "struct vs_out {\n"
                "  float4 pos [[position]];\n"
                "  float2 uv;\n"
                "  float4 data;\n"
                "};\n"
                "vertex vs_out _main(vs_in in [[stage_in]]) {\n"
                "  vs_out out;\n"
                "  out.pos = float4((in.pos.xy - 0.5) * float2(2.0, -2.0), 0.5, 1.0);\n"
                "  out.uv  = in.uv;"
                "  out.data = in.data;\n"
                "  return out;\n"
                "}\n";
            offscreen_fs_src =
                "#include <metal_stdlib>\n"
                "using namespace metal;\n"
                "struct ps_in {\n"
                "  float2 uv;\n"
                "  float4 data;\n"
                "};\n"
                "fragment float4 _main(ps_in in [[stage_in]],\n"
                "                      texture2d<float> tile_tex [[texture(0)]],\n"
                "                      texture2d<float> pal_tex [[texture(1)]],\n"
                "                      sampler tile_smp [[sampler(0)]],\n"
                "                      sampler pal_smp [[sampler(1)]])\n"
                "{\n"
                "  float color_code = in.data.x;\n" // (0..31) / 255
                "  float tile_color = tile_tex.sample(tile_smp, in.uv).x;\n" // (0..3) / 255
                "  float2 pal_uv = float2(color_code * 4 + tile_color, 0);\n"
                "  float4 color = pal_tex.sample(pal_smp, pal_uv) * float4(1, 1, 1, in.data.y);\n"
                "  return color;\n"
                "}\n";
            display_vs_src =
                "#include <metal_stdlib>\n"
                "using namespace metal;\n"
                "struct vs_in {\n"
                "  float4 pos [[attribute(0)]];\n"
                "};\n"
                "struct vs_out {\n"
                "  float4 pos [[position]];\n"
                "  float2 uv;\n"
                "};\n"
                "vertex vs_out _main(vs_in in[[stage_in]]) {\n"
                "  vs_out out;\n"
                "  out.pos = float4((in.pos.xy - 0.5) * float2(2.0, -2.0), 0.0, 1.0);\n"
                "  out.uv = in.pos.xy;\n"
                "  return out;\n"
                "}\n";
            display_fs_src =
                "#include <metal_stdlib>\n"
                "using namespace metal;\n"
                "struct ps_in {\n"
                "  float2 uv;\n"
                "};\n"
                "fragment float4 _main(ps_in in [[stage_in]],\n"
                "                      texture2d<float> tex [[texture(0)]],\n"
                "                      sampler smp [[sampler(0)]])\n"
                "{\n"
                "  return tex.sample(smp, in.uv);\n"
                "}\n";
            break;
        case SG_BACKEND_D3D11:
            offscreen_vs_src =
                "struct vs_in {\n"
                "  float4 pos: POSITION;\n"
                "  float2 uv: TEXCOORD0;\n"
                "  float4 data: TEXCOORD1;\n"
                "};\n"
                "struct vs_out {\n"
                "  float2 uv: UV;\n"
                "  float4 data: DATA;\n"
                "  float4 pos: SV_Position;\n"
                "};\n"
                "vs_out main(vs_in inp) {\n"
                "  vs_out outp;"
                "  outp.pos = float4(inp.pos.xy * float2(2.0, -2.0) + float2(-1.0, 1.0), 0.0, 1.0);\n"
                "  outp.uv  = inp.uv;"
                "  outp.data = inp.data;\n"
                "  return outp;\n"
                "}\n";
            offscreen_fs_src =
                "Texture2D<float4> tile_tex: register(t0);\n"
                "Texture2D<float4> pal_tex: register(t1);\n"
                "sampler tile_smp: register(s0);\n"
                "sampler pal_smp: register(s1);\n"
                "float4 main(float2 uv: UV, float4 data: DATA): SV_Target0 {\n"
                "  float color_code = data.x;\n"
                "  float tile_color = tile_tex.Sample(tile_smp, uv).x;\n"
                "  float2 pal_uv = float2(color_code * 4 + tile_color, 0);\n"
                "  float4 color = pal_tex.Sample(pal_smp, pal_uv) * float4(1, 1, 1, data.y);\n"
                "  return color;\n"
                "}\n";
            display_vs_src =
                "struct vs_out {\n"
                "  float2 uv: UV;\n"
                "  float4 pos: SV_Position;\n"
                "};\n"
                "vs_out main(float4 pos: POSITION) {\n"
                "  vs_out outp;\n"
                "  outp.pos = float4((pos.xy - 0.5) * float2(2.0, -2.0), 0.0, 1.0);\n"
                "  outp.uv = pos.xy;\n"
                "  return outp;\n"
                "}\n";
            display_fs_src =
                "Texture2D<float4> tex: register(t0);\n"
                "sampler smp: register(s0);\n"
                "float4 main(float2 uv: UV): SV_Target0 {\n"
                "  return tex.Sample(smp, uv);\n"
                "}\n";
            break;
        default:
            assert(false);
    }

    // create pipeline and shader object for rendering into offscreen render target
    state.gfx.offscreen.pip = sg_make_pipeline(&(sg_pipeline_desc){
        .shader = sg_make_shader(&(sg_shader_desc){
           .attrs = {
                [0] = { .sem_name="POSITION" },
                [1] = { .sem_name="TEXCOORD", .sem_index=0 },
                [2] = { .sem_name="TEXCOORD", .sem_index=1 },
            },
            .vs.source = offscreen_vs_src,
            .fs = {
                .images[0].type = SG_IMAGETYPE_2D,
                .images[1].type = SG_IMAGETYPE_2D,
                .source = offscreen_fs_src
            }
        }),
        .layout = {
            .attrs = {
                [0].format = SG_VERTEXFORMAT_FLOAT2,
                [1].format = SG_VERTEXFORMAT_FLOAT2,
                [2].format = SG_VERTEXFORMAT_UBYTE4N,
            }
        },
        .blend = {
            .enabled = true,
            .color_format = SG_PIXELFORMAT_RGBA8,
            .depth_format = SG_PIXELFORMAT_NONE,
            .src_factor_rgb = SG_BLENDFACTOR_SRC_ALPHA,
            .dst_factor_rgb = SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA,
        }
    });
    
    // create pipeline and shader for rendering into display
    state.gfx.display.pip = sg_make_pipeline(&(sg_pipeline_desc){
        .shader = sg_make_shader(&(sg_shader_desc){
            .attrs[0].sem_name="POSITION",
            .vs.source = display_vs_src,
            .fs = {
                .images[0].type = SG_IMAGETYPE_2D,
                .source = display_fs_src
            }
        }),
        .layout.attrs[0].format = SG_VERTEXFORMAT_FLOAT2,
        .primitive_type = SG_PRIMITIVETYPE_TRIANGLE_STRIP
    });

    // create a render target image with a fixed upscale ratio
    state.gfx.offscreen.render_target = sg_make_image(&(sg_image_desc){
        .render_target = true,
        .width = DISPLAY_PIXELS_X * 2,
        .height = DISPLAY_PIXELS_Y * 2,
        .pixel_format = SG_PIXELFORMAT_RGBA8,
        .min_filter = SG_FILTER_LINEAR,
        .mag_filter = SG_FILTER_LINEAR,
        .wrap_u = SG_WRAP_CLAMP_TO_EDGE,
        .wrap_v = SG_WRAP_CLAMP_TO_EDGE,
    });

    // pass object for rendering into the offscreen render target
    state.gfx.offscreen.pass = sg_make_pass(&(sg_pass_desc){
        .color_attachments[0].image = state.gfx.offscreen.render_target
    });

    // create the 'tile-ROM-texture'
    state.gfx.offscreen.tile_img = sg_make_image(&(sg_image_desc){
        .width  = TILE_TEXTURE_WIDTH,
        .height = TILE_TEXTURE_HEIGHT,
        .pixel_format = SG_PIXELFORMAT_R8,
        .min_filter = SG_FILTER_NEAREST,
        .mag_filter = SG_FILTER_NEAREST,
        .wrap_u = SG_WRAP_CLAMP_TO_EDGE,
        .wrap_v = SG_WRAP_CLAMP_TO_EDGE,
        .content.subimage[0][0] = {
            .ptr = state.gfx.tile_pixels,
            .size = sizeof(state.gfx.tile_pixels)
        }
    });

    // create the palette texture
    state.gfx.offscreen.palette_img = sg_make_image(&(sg_image_desc){
        .width = 256,
        .height = 1,
        .pixel_format = SG_PIXELFORMAT_RGBA8,
        .min_filter = SG_FILTER_NEAREST,
        .mag_filter = SG_FILTER_NEAREST,
        .wrap_u = SG_WRAP_CLAMP_TO_EDGE,
        .wrap_v = SG_WRAP_CLAMP_TO_EDGE,
        .content.subimage[0][0] = {
            .ptr = state.gfx.color_palette,
            .size = sizeof(state.gfx.color_palette)
        }
    });
}

/*
    8x4 tile decoder (taken from: https://github.com/floooh/chips/blob/master/systems/namco.h)

    This decodes 2-bit-per-pixel tile data from Pacman ROM dumps into
    8-bit-per-pixel texture data (without doing the RGB palette lookup,
    this happens during rendering in the pixel shader).

    The Pacman ROM tile layout isn't exactly strightforward, both 8x8 tiles
    and 16x16 sprites are built from 8x4 pixel blocks layed out linearly
    in memory, and to add to the confusion, since Pacman is an arcade machine
    with the display 90 degree rotated, all the ROM tile data is counter-rotated.

    Tile decoding only happens once at startup from ROM dumps into a texture.
*/
static inline void gfx_decode_tile_8x4(
    uint32_t tex_x,
    uint32_t tex_y,
    uint8_t* tile_base,
    uint32_t tile_stride,
    uint32_t tile_offset,
    uint8_t tile_code)
{
    for (uint32_t tx = 0; tx < TILE_WIDTH; tx++) {
        uint32_t ti = tile_code * tile_stride + tile_offset + (7 - tx);
        for (uint32_t ty = 0; ty < (TILE_HEIGHT/2); ty++) {
            uint8_t p_hi = (tile_base[ti] >> (7 - ty)) & 1;
            uint8_t p_lo = (tile_base[ti] >> (3 - ty)) & 1;
            uint8_t p = (p_hi << 1) | p_lo;
            state.gfx.tile_pixels[tex_y + ty][tex_x + tx] = p;
        }
    }
}

// decode an 8x8 tile into the tile texture's upper half
static inline void gfx_decode_tile(uint8_t tile_code) {
    uint32_t x = tile_code * TILE_WIDTH;
    uint32_t y0 = 0;
    uint32_t y1 = y0 + (TILE_HEIGHT / 2);
    gfx_decode_tile_8x4(x, y0, rom_tiles, 16, 8, tile_code);
    gfx_decode_tile_8x4(x, y1, rom_tiles, 16, 0, tile_code);
}

// decode a 16x16 sprite into the tile texture's lower half
static inline void gfx_decode_sprite(uint8_t sprite_code) {
    uint32_t x0 = sprite_code * SPRITE_WIDTH;
    uint32_t x1 = x0 + TILE_WIDTH;
    uint32_t y0 = TILE_HEIGHT;
    uint32_t y1 = y0 + (TILE_HEIGHT / 2);
    uint32_t y2 = y1 + (TILE_HEIGHT / 2);
    uint32_t y3 = y2 + (TILE_HEIGHT / 2);
    gfx_decode_tile_8x4(x0, y0, rom_sprites, 64, 40, sprite_code);
    gfx_decode_tile_8x4(x1, y0, rom_sprites, 64,  8, sprite_code);
    gfx_decode_tile_8x4(x0, y1, rom_sprites, 64, 48, sprite_code);
    gfx_decode_tile_8x4(x1, y1, rom_sprites, 64, 16, sprite_code);
    gfx_decode_tile_8x4(x0, y2, rom_sprites, 64, 56, sprite_code);
    gfx_decode_tile_8x4(x1, y2, rom_sprites, 64, 24, sprite_code);
    gfx_decode_tile_8x4(x0, y3, rom_sprites, 64, 32, sprite_code);
    gfx_decode_tile_8x4(x1, y3, rom_sprites, 64,  0, sprite_code);
}

// decode the Pacman tile- and sprite-ROM-dumps into a 8bpp texture
static void gfx_decode_tiles(void) {
    for (uint32_t tile_code = 0; tile_code < 256; tile_code++) {
        gfx_decode_tile(tile_code);
    }
    for (uint32_t sprite_code = 0; sprite_code < 64; sprite_code++) {
        gfx_decode_sprite(sprite_code);
    }
    // write a special opaque 16x16 block which will be used for the fade-effect
    for (uint32_t y = TILE_HEIGHT; y < TILE_TEXTURE_HEIGHT; y++) {
        for (uint32_t x = 64*SPRITE_WIDTH; x < 65*SPRITE_WIDTH; x++) {
            state.gfx.tile_pixels[y][x] = 1;
        }
    }
}

/* decode the Pacman color palette into a palette texture, on the original
    hardware, color lookup happens in two steps, first through 256-entry
    palette which indirects into a 32-entry hardware-color palette
    (of which only 16 entries are used on the Pacman hardware)
*/
static void gfx_decode_color_palette(void) {
    uint32_t hw_colors[32];
    for (int i = 0; i < 32; i++) {
       /*
           Each color ROM entry describes an RGB color in 1 byte:

           | 7| 6| 5| 4| 3| 2| 1| 0|
           |B1|B0|G2|G1|G0|R2|R1|R0|

           Intensities are: 0x97 + 0x47 + 0x21
        */
        uint8_t rgb = rom_hwcolors[i];
        uint8_t r = ((rgb>>0)&1) * 0x21 + ((rgb>>1)&1) * 0x47 + ((rgb>>2)&1) * 0x97;
        uint8_t g = ((rgb>>3)&1) * 0x21 + ((rgb>>4)&1) * 0x47 + ((rgb>>5)&1) * 0x97;
        uint8_t b = ((rgb>>6)&1) * 0x47 + ((rgb>>7)&1) * 0x97;
        hw_colors[i] = 0xFF000000 | (b<<16) | (g<<8) | r;
    }
    for (int i = 0; i < 256; i++) {
        state.gfx.color_palette[i] = hw_colors[rom_palette[i] & 0xF];
        // first color in each color block is transparent
        if ((i & 3) == 0) {
            state.gfx.color_palette[i] &= 0x00FFFFFF;
        }
    }
}

// initialize the gfx subsystem
static void gfx_init(void) {
    disable(&state.gfx.fadein);
    disable(&state.gfx.fadeout);
    state.gfx.fade = 0xFF;
    spr_clear();
    gfx_decode_tiles();
    gfx_decode_color_palette(); 
    gfx_create_resources();
}

static void gfx_add_vertex(float x, float y, float u, float v, uint8_t color_code, uint8_t fade) {
    assert(state.gfx.num_vertices < MAX_VERTICES);
    vertex_t* vtx = &state.gfx.vertices[state.gfx.num_vertices++];
    vtx->x = x;
    vtx->y = y;
    vtx->u = u;
    vtx->v = v;
    vtx->attr = (fade<<8) | color_code;
}

static void gfx_add_tile_vertices(uint32_t tx, uint32_t ty, uint8_t tile_code, uint8_t color_code) {
    assert((tx >= 0) && (tx < DISPLAY_TILES_X) && (ty >= 0) && (ty < DISPLAY_TILES_Y));
    const float dx = 1.0f / DISPLAY_TILES_X;
    const float dy = 1.0f / DISPLAY_TILES_Y;
    const float du = (float)TILE_WIDTH / TILE_TEXTURE_WIDTH;
    const float dv = (float)TILE_HEIGHT / TILE_TEXTURE_HEIGHT;

    const float x0 = tx * dx;
    const float x1 = x0 + dx;
    const float y0 = ty * dy;
    const float y1 = y0 + dy;
    const float u0 = tile_code * du;
    const float u1 = u0 + du;
    const float v0 = 0.0f;
    const float v1 = dv;
    /*
        x0,y0
        +-----+
        | *   |
        |   * |
        +-----+
                x1,y1
    */
    gfx_add_vertex(x0, y0, u0, v0, color_code, 0xFF);
    gfx_add_vertex(x1, y0, u1, v0, color_code, 0xFF);
    gfx_add_vertex(x1, y1, u1, v1, color_code, 0xFF);
    gfx_add_vertex(x0, y0, u0, v0, color_code, 0xFF);
    gfx_add_vertex(x1, y1, u1, v1, color_code, 0xFF);
    gfx_add_vertex(x0, y1, u0, v1, color_code, 0xFF);
}

static void gfx_add_playfield_vertices(void) {
    for (uint32_t ty = 0; ty < DISPLAY_TILES_Y; ty++) {
        for (uint32_t tx = 0; tx < DISPLAY_TILES_X; tx++) {
            const uint8_t tile_code = state.gfx.video_ram[ty][tx];
            const uint8_t color_code = state.gfx.color_ram[ty][tx] & 0x1F;
            gfx_add_tile_vertices(tx, ty, tile_code, color_code);
        }
    }
}

static void gfx_add_debugmarker_vertices(void) {
    for (int i = 0; i < NUM_DEBUG_MARKERS; i++) {
        const debugmarker_t* dbg = &state.gfx.debug_marker[i];
        if (dbg->enabled) {
            gfx_add_tile_vertices(dbg->tile_pos.x, dbg->tile_pos.y, dbg->tile, dbg->color);
        }
    }
}

static void gfx_add_sprite_vertices(void) {
    const float dx = 1.0f / DISPLAY_PIXELS_X;
    const float dy = 1.0f / DISPLAY_PIXELS_Y;
    const float du = (float)SPRITE_WIDTH / TILE_TEXTURE_WIDTH;
    const float dv = (float)SPRITE_HEIGHT / TILE_TEXTURE_HEIGHT;
    for (int i = 0; i < NUM_SPRITES; i++) {
        const sprite_t* spr = &state.gfx.sprite[i];
        if (spr->enabled) {
            float x0, x1, y0, y1;
            if (spr->flipx) {
                x1 = spr->pos.x * dx;
                x0 = x1 + dx * SPRITE_WIDTH;
            }
            else {
                x0 = spr->pos.x * dx;
                x1 = x0 + dx * SPRITE_WIDTH;
            }
            if (spr->flipy) {
                y1 = spr->pos.y * dy;
                y0 = y1 + dy * SPRITE_HEIGHT;
            }
            else {
                y0 = spr->pos.y * dy;
                y1 = y0 + dy * SPRITE_HEIGHT;
            }
            const float u0 = spr->tile * du;
            const float u1 = u0 + du;
            const float v0 = ((float)TILE_HEIGHT / TILE_TEXTURE_HEIGHT);
            const float v1 = v0 + dv;
            const uint8_t color = spr->color;
            gfx_add_vertex(x0, y0, u0, v0, color, 0xFF);
            gfx_add_vertex(x1, y0, u1, v0, color, 0xFF);
            gfx_add_vertex(x1, y1, u1, v1, color, 0xFF);
            gfx_add_vertex(x0, y0, u0, v0, color, 0xFF);
            gfx_add_vertex(x1, y1, u1, v1, color, 0xFF);
            gfx_add_vertex(x0, y1, u0, v1, color, 0xFF);
        }
    }
}

static void gfx_add_fade_vertices(void) {
    // sprite tile 64 is a special 16x16 opaque block
    const float du = (float)SPRITE_WIDTH / TILE_TEXTURE_WIDTH;
    const float dv = (float)SPRITE_HEIGHT / TILE_TEXTURE_HEIGHT;
    const float u0 = 64 * du;
    const float u1 = u0 + du;
    const float v0 = (float)TILE_HEIGHT / TILE_TEXTURE_HEIGHT;
    const float v1 = v0 + dv;

    const uint8_t fade = state.gfx.fade;
    gfx_add_vertex(0.0f, 0.0f, u0, v0, 0, fade);
    gfx_add_vertex(1.0f, 0.0f, u1, v0, 0, fade);
    gfx_add_vertex(1.0f, 1.0f, u1, v1, 0, fade);
    gfx_add_vertex(0.0f, 0.0f, u0, v0, 0, fade);
    gfx_add_vertex(1.0f, 1.0f, u1, v1, 0, fade);
    gfx_add_vertex(0.0f, 1.0f, u0, v1, 0, fade);
}

// adjust the viewport so that the aspect ratio is always correct
static void gfx_adjust_viewport(int canvas_width, int canvas_height) {
    const float canvas_aspect = (float)canvas_width / (float)canvas_height;
    const float playfield_aspect = (float)DISPLAY_TILES_X / (float)DISPLAY_TILES_Y;
    int vp_x, vp_y, vp_w, vp_h;
    const int border = 10;
    if (playfield_aspect < canvas_aspect) {
        vp_y = border;
        vp_h = canvas_height - 2*border;
        vp_w = (int)(canvas_height * playfield_aspect - 2*border);
        vp_x = (canvas_width - vp_w) / 2;
    }
    else {
        vp_x = border;
        vp_w = canvas_width - 2*border;
        vp_h = (int)(canvas_width / playfield_aspect - 2*border);
        vp_y = (canvas_height - vp_h) / 2;
    }
    sg_apply_viewport(vp_x, vp_y, vp_w, vp_h, true);
}

// handle fadein/fadeout
static void gfx_fade(void) {
    if (between(state.gfx.fadein, 0, FADE_TICKS)) {
        float t = (float)since(state.gfx.fadein) / FADE_TICKS;
        state.gfx.fade = (uint8_t) (255.0f * (1.0f - t));
    }
    if (after(state.gfx.fadein, FADE_TICKS)) {
        state.gfx.fade = 0;
    }
    if (between(state.gfx.fadeout, 0, FADE_TICKS)) {
        float t = (float)since(state.gfx.fadeout) / FADE_TICKS;
        state.gfx.fade = (uint8_t) (255.0f * t);
    }
    if (after(state.gfx.fadeout, FADE_TICKS)) {
        state.gfx.fade = 255;
    }
}

static void gfx_draw(void) {
    // handle fade in/out
    gfx_fade();

    // update the playfield and sprite vertex buffer
    state.gfx.num_vertices = 0;
    gfx_add_playfield_vertices();
    gfx_add_sprite_vertices();
    gfx_add_debugmarker_vertices();
    if (state.gfx.fade > 0) {
        gfx_add_fade_vertices();
    }
    assert(state.gfx.num_vertices <= MAX_VERTICES);
    sg_update_buffer(state.gfx.offscreen.vbuf, &state.gfx.vertices, state.gfx.num_vertices * sizeof(vertex_t));

    // render tiles and sprites into offscreen render target
    sg_begin_pass(state.gfx.offscreen.pass, &state.gfx.pass_action);
    sg_apply_pipeline(state.gfx.offscreen.pip);
    sg_apply_bindings(&(sg_bindings){
        .vertex_buffers[0] = state.gfx.offscreen.vbuf,
        .fs_images[0] = state.gfx.offscreen.tile_img,
        .fs_images[1] = state.gfx.offscreen.palette_img,
    });
    sg_draw(0, state.gfx.num_vertices, 1);
    sg_end_pass();

    // upscale-render the offscreen render target into the display framebuffer
    const int canvas_width = sapp_width();
    const int canvas_height = sapp_height();
    sg_begin_default_pass(&state.gfx.pass_action, canvas_width, canvas_height);
    gfx_adjust_viewport(canvas_width, canvas_height);
    sg_apply_pipeline(state.gfx.display.pip);
    sg_apply_bindings(&(sg_bindings){
        .vertex_buffers[0] = state.gfx.display.quad_vbuf,
        .fs_images[0] = state.gfx.offscreen.render_target
    });
    sg_draw(0, 4, 1);
    sg_end_pass();
    sg_commit();
}

/*== EMBEDDED DATA ===========================================================*/

// Pacman sprite ROM dump
static uint8_t rom_tiles[4096] = {
    0xcc, 0xee, 0x11, 0x11, 0x33, 0xee, 0xcc, 0x0, 0x11, 0x33, 0x66, 0x44, 0x44, 0x33, 0x11, 0x0,
    0x11, 0x11, 0xff, 0xff, 0x11, 0x11, 0x0, 0x0, 0x0, 0x0, 0x77, 0x77, 0x22, 0x0, 0x0, 0x0,
    0x11, 0x99, 0xdd, 0xdd, 0xff, 0x77, 0x33, 0x0, 0x33, 0x77, 0x55, 0x44, 0x44, 0x66, 0x22, 0x0,
    0x66, 0xff, 0x99, 0x99, 0x99, 0x33, 0x22, 0x0, 0x44, 0x66, 0x77, 0x55, 0x44, 0x44, 0x0, 0x0,
    0x44, 0xff, 0xff, 0x44, 0x44, 0xcc, 0xcc, 0x0, 0x0, 0x77, 0x77, 0x66, 0x33, 0x11, 0x0, 0x0,
    0xee, 0xff, 0x11, 0x11, 0x11, 0x33, 0x22, 0x0, 0x0, 0x55, 0x55, 0x55, 0x55, 0x77, 0x77, 0x0,
    0x66, 0xff, 0x99, 0x99, 0x99, 0xff, 0xee, 0x0, 0x0, 0x44, 0x44, 0x44, 0x66, 0x33, 0x11, 0x0,
    0x0, 0x0, 0x88, 0xff, 0x77, 0x0, 0x0, 0x0, 0x66, 0x77, 0x55, 0x44, 0x44, 0x66, 0x66, 0x0,
    0x66, 0x77, 0xdd, 0xdd, 0x99, 0x99, 0x66, 0x0, 0x0, 0x33, 0x44, 0x44, 0x55, 0x77, 0x33, 0x0,
    0xcc, 0xee, 0xbb, 0x99, 0x99, 0x99, 0x0, 0x0, 0x33, 0x77, 0x44, 0x44, 0x44, 0x77, 0x33, 0x0,
    0xff, 0xff, 0x44, 0x44, 0x44, 0xff, 0xff, 0x0, 0x11, 0x33, 0x66, 0x44, 0x66, 0x33, 0x11, 0x0,
    0x66, 0xff, 0x99, 0x99, 0x99, 0xff, 0xff, 0x0, 0x33, 0x77, 0x44, 0x44, 0x44, 0x77, 0x77, 0x0,
    0x22, 0x33, 0x11, 0x11, 0x33, 0xee, 0xcc, 0x0, 0x22, 0x66, 0x44, 0x44, 0x66, 0x33, 0x11, 0x0,
    0xcc, 0xee, 0x33, 0x11, 0x11, 0xff, 0xff, 0x0, 0x11, 0x33, 0x66, 0x44, 0x44, 0x77, 0x77, 0x0,
    0x11, 0x99, 0x99, 0x99, 0xff, 0xff, 0x0, 0x0, 0x44, 0x44, 0x44, 0x44, 0x77, 0x77, 0x0, 0x0,
    0x0, 0x88, 0x88, 0x88, 0x88, 0xff, 0xff, 0x0, 0x44, 0x44, 0x44, 0x44, 0x44, 0x77, 0x77, 0x0,
    0x0, 0x0, 0x0, 0x8, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x8, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x8, 0xc, 0xc, 0x8, 0x0, 0x0, 0x0, 0x0, 0x1, 0x3, 0x3, 0x1, 0x0, 0x0,
    0x0, 0x0, 0x8, 0xc, 0xc, 0x8, 0x0, 0x0, 0x0, 0x0, 0x1, 0x3, 0x3, 0x1, 0x0, 0x0,
    0xc, 0xe, 0xf, 0xf, 0xf, 0xf, 0xe, 0xc, 0x3, 0x7, 0xf, 0xf, 0xf, 0xf, 0x7, 0x3,
    0xc, 0xe, 0xf, 0xf, 0xf, 0xf, 0xe, 0xc, 0x3, 0x7, 0xf, 0xf, 0xf, 0xf, 0x7, 0x3,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x77, 0xff, 0xff, 0xff, 0xee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33,
    0xee, 0xcc, 0xcc, 0x88, 0x88, 0x0, 0x0, 0x0, 0x33, 0x33, 0x33, 0x11, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88, 0x88, 0x0, 0x0, 0x0, 0xcc, 0xee, 0xff, 0xff, 0xff,
    0x88, 0x88, 0x88, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x77, 0x77, 0x33, 0x22, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x66, 0x66, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0xdd, 0x0, 0xee, 0xdd, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0xdd, 0x0, 0xee, 0xdd, 0x0, 0x0,
    0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0x77, 0xff, 0xcc, 0xcc, 0xcc, 0xcc, 0xff, 0xff,
    0xbb, 0xbb, 0xbb, 0xbb, 0xff, 0xff, 0x0, 0x0, 0xdd, 0xdd, 0xdd, 0xdd, 0xdd, 0x11, 0x0, 0x0,
    0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0xcc, 0xcc, 0xff, 0xff, 0x0, 0x0, 0x77, 0xff,
    0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0, 0x77, 0xff, 0xcc, 0xcc, 0xff, 0xff,
    0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0xff, 0xee, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xff, 0x77,
    0x33, 0x33, 0x33, 0x33, 0xff, 0xee, 0x0, 0x0, 0xcc, 0xcc, 0xcc, 0xcc, 0xff, 0x77, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x77, 0xff,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x88, 0xcc, 0x22, 0x22, 0x66, 0xcc, 0x88, 0x0, 0x33, 0x77, 0xcc, 0x88, 0x88, 0x77, 0x33, 0x0,
    0x22, 0x22, 0xee, 0xee, 0x22, 0x22, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0x44, 0x0, 0x0, 0x0,
    0x22, 0x22, 0xaa, 0xaa, 0xee, 0xee, 0x66, 0x0, 0x66, 0xff, 0xbb, 0x99, 0x99, 0xcc, 0x44, 0x0,
    0xcc, 0xee, 0x22, 0x22, 0x22, 0x66, 0x44, 0x0, 0x88, 0xdd, 0xff, 0xbb, 0x99, 0x88, 0x0, 0x0,
    0x88, 0xee, 0xee, 0x88, 0x88, 0x88, 0x88, 0x0, 0x0, 0xff, 0xff, 0xcc, 0x66, 0x33, 0x11, 0x0,
    0xcc, 0xee, 0x22, 0x22, 0x22, 0x66, 0x44, 0x0, 0x11, 0xbb, 0xaa, 0xaa, 0xaa, 0xee, 0xee, 0x0,
    0xcc, 0xee, 0x22, 0x22, 0x22, 0xee, 0xcc, 0x0, 0x0, 0x99, 0x99, 0x99, 0xdd, 0x77, 0x33, 0x0,
    0x0, 0x0, 0x0, 0xee, 0xee, 0x0, 0x0, 0x0, 0xcc, 0xee, 0xbb, 0x99, 0x88, 0xcc, 0xcc, 0x0,
    0xcc, 0xee, 0xaa, 0xaa, 0x22, 0x22, 0xcc, 0x0, 0x0, 0x66, 0x99, 0x99, 0xbb, 0xff, 0x66, 0x0,
    0x88, 0xcc, 0x66, 0x22, 0x22, 0x22, 0x0, 0x0, 0x77, 0xff, 0x99, 0x99, 0x99, 0xff, 0x66, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x88, 0x44, 0x22, 0x0, 0x88, 0x44, 0x22, 0x11, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x11, 0x11, 0x0, 0x0, 0x0,
    0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88,
    0xff, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0x88, 0xff,
    0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0x11, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xee, 0xee, 0x88, 0x88, 0x88, 0xee, 0xee, 0x0, 0x33, 0x77, 0xcc, 0x88, 0xcc, 0x77, 0x33, 0x0,
    0xcc, 0xee, 0x22, 0x22, 0x22, 0xee, 0xee, 0x0, 0x66, 0xff, 0x99, 0x99, 0x99, 0xff, 0xff, 0x0,
    0x44, 0x66, 0x22, 0x22, 0x66, 0xcc, 0x88, 0x0, 0x44, 0xcc, 0x88, 0x88, 0xcc, 0x77, 0x33, 0x0,
    0x88, 0xcc, 0x66, 0x22, 0x22, 0xee, 0xee, 0x0, 0x33, 0x77, 0xcc, 0x88, 0x88, 0xff, 0xff, 0x0,
    0x22, 0x22, 0x22, 0x22, 0xee, 0xee, 0x0, 0x0, 0x88, 0x99, 0x99, 0x99, 0xff, 0xff, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0xee, 0x0, 0x88, 0x99, 0x99, 0x99, 0x99, 0xff, 0xff, 0x0,
    0xee, 0xee, 0x22, 0x22, 0x66, 0xcc, 0x88, 0x0, 0x99, 0x99, 0x99, 0x88, 0xcc, 0x77, 0x33, 0x0,
    0xee, 0xee, 0x0, 0x0, 0x0, 0xee, 0xee, 0x0, 0xff, 0xff, 0x11, 0x11, 0x11, 0xff, 0xff, 0x0,
    0x22, 0x22, 0xee, 0xee, 0x22, 0x22, 0x0, 0x0, 0x88, 0x88, 0xff, 0xff, 0x88, 0x88, 0x0, 0x0,
    0xcc, 0xee, 0x22, 0x22, 0x22, 0x66, 0x44, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x22, 0x66, 0xee, 0xcc, 0x88, 0xee, 0xee, 0x0, 0x88, 0xcc, 0x66, 0x33, 0x11, 0xff, 0xff, 0x0,
    0x22, 0x22, 0x22, 0x22, 0xee, 0xee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0x0, 0x0,
    0xee, 0xee, 0x0, 0x88, 0x0, 0xee, 0xee, 0x0, 0xff, 0xff, 0x77, 0x33, 0x77, 0xff, 0xff, 0x0,
    0xee, 0xee, 0xcc, 0x88, 0x0, 0xee, 0xee, 0x0, 0xff, 0xff, 0x11, 0x33, 0x77, 0xff, 0xff, 0x0,
    0xcc, 0xee, 0x22, 0x22, 0x22, 0xee, 0xcc, 0x0, 0x77, 0xff, 0x88, 0x88, 0x88, 0xff, 0x77, 0x0,
    0x0, 0x88, 0x88, 0x88, 0x88, 0xee, 0xee, 0x0, 0x77, 0xff, 0x88, 0x88, 0x88, 0xff, 0xff, 0x0,
    0xaa, 0xcc, 0xee, 0xaa, 0x22, 0xee, 0xcc, 0x0, 0x77, 0xff, 0x88, 0x88, 0x88, 0xff, 0x77, 0x0,
    0x22, 0x66, 0xee, 0xcc, 0x88, 0xee, 0xee, 0x0, 0x77, 0xff, 0x99, 0x88, 0x88, 0xff, 0xff, 0x0,
    0xcc, 0xee, 0x22, 0x22, 0x22, 0x66, 0x44, 0x0, 0x0, 0x55, 0xdd, 0x99, 0x99, 0xff, 0x66, 0x0,
    0x0, 0x0, 0xee, 0xee, 0x0, 0x0, 0x0, 0x0, 0x88, 0x88, 0xff, 0xff, 0x88, 0x88, 0x0, 0x0,
    0xcc, 0xee, 0x22, 0x22, 0x22, 0xee, 0xcc, 0x0, 0xff, 0xff, 0x0, 0x0, 0x0, 0xff, 0xff, 0x0,
    0x0, 0x88, 0xcc, 0xee, 0xcc, 0x88, 0x0, 0x0, 0xff, 0xff, 0x11, 0x0, 0x11, 0xff, 0xff, 0x0,
    0xee, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0xee, 0x0, 0xff, 0xff, 0x11, 0x33, 0x11, 0xff, 0xff, 0x0,
    0x66, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0x66, 0x0, 0xcc, 0xee, 0x77, 0x33, 0x77, 0xee, 0xcc, 0x0,
    0x0, 0x0, 0xee, 0xee, 0x0, 0x0, 0x0, 0x0, 0xee, 0xff, 0x11, 0x11, 0xff, 0xee, 0x0, 0x0,
    0x22, 0x22, 0x22, 0xaa, 0xee, 0xee, 0x66, 0x0, 0xcc, 0xee, 0xff, 0xbb, 0x99, 0x88, 0x88, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x88, 0x22, 0x0, 0x0, 0x0, 0xcc, 0xee, 0xff, 0x33, 0x0, 0x0, 0x0,
    0xcc, 0x22, 0x11, 0x55, 0x55, 0x99, 0x22, 0xcc, 0x33, 0x44, 0x88, 0xaa, 0xaa, 0x99, 0x44, 0x33,
    0x0, 0x0, 0x0, 0x0, 0x88, 0x88, 0x88, 0xee, 0x22, 0x22, 0x0, 0x11, 0x22, 0x22, 0x22, 0x33,
    0xaa, 0xaa, 0xaa, 0x22, 0x0, 0x0, 0x0, 0xee, 0x22, 0x22, 0x22, 0x11, 0x0, 0x22, 0x22, 0x33,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x44, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x22,
    0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xe, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x33, 0x77, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x33, 0x33, 0x33, 0x33, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0x0,
    0x33, 0x33, 0x77, 0x77, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee,
    0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x33, 0x33, 0x33, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0xee, 0xee, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x33, 0x33, 0x33, 0x33, 0x33, 0x77, 0x77, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee, 0xee,
    0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x33, 0x33, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xee, 0xee, 0xee, 0xee, 0xee, 0x0, 0x0, 0x0,
    0x33, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xce, 0xee, 0xee, 0xee, 0x66, 0x22, 0x22, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x22, 0xcc, 0x0, 0x22, 0xee, 0x22, 0x0, 0x0, 0x88, 0x77, 0x0, 0x0, 0xff, 0x44, 0x0, 0x0,
    0x22, 0xcc, 0x0, 0xcc, 0x22, 0x22, 0x22, 0x44, 0x88, 0x77, 0x0, 0x88, 0xdd, 0xaa, 0x88, 0x88,
    0x22, 0xcc, 0x0, 0xcc, 0x22, 0x22, 0x22, 0x44, 0x88, 0x77, 0x0, 0x99, 0xaa, 0xaa, 0xaa, 0xee,
    0x22, 0xcc, 0x0, 0x0, 0x0, 0xee, 0x0, 0x0, 0x88, 0x77, 0x0, 0xcc, 0xbb, 0x88, 0x88, 0xcc,
    0x0, 0xcc, 0x22, 0x22, 0xcc, 0x0, 0xcc, 0x22, 0x0, 0x77, 0x88, 0x88, 0x77, 0x0, 0x77, 0x88,
    0xcc, 0x22, 0x22, 0xcc, 0x0, 0x22, 0xee, 0x22, 0x77, 0x88, 0x88, 0x77, 0x0, 0x0, 0xff, 0x44,
    0x66, 0x22, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88, 0x66, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xcc, 0x22, 0x22, 0xcc, 0x0, 0x22, 0x22, 0xaa, 0x77, 0x88, 0x88, 0x77, 0x0, 0x66, 0x99, 0x88,
    0x22, 0x44, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88, 0x88, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xcc, 0x22, 0x22, 0xcc, 0x0, 0xcc, 0x22, 0x22, 0x77, 0x88, 0x88, 0x77, 0x0, 0x88, 0xdd, 0xaa,
    0x22, 0x44, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xaa, 0xee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xcc, 0x22, 0x22, 0xcc, 0x0, 0xcc, 0x22, 0x22, 0x77, 0x88, 0x88, 0x77, 0x0, 0x99, 0xaa, 0xaa,
    0x22, 0xcc, 0x0, 0xcc, 0x22, 0x22, 0xcc, 0x0, 0x88, 0x77, 0x0, 0x77, 0x88, 0x88, 0x77, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xcc, 0x22, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x77, 0x88,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0xc0, 0x20, 0x90, 0x80, 0x0, 0x0, 0x30, 0x30, 0x10, 0x10, 0x0, 0x0,
    0x41, 0x21, 0x12, 0x3, 0x3, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x8, 0xc, 0xc, 0x8c, 0xc, 0x0, 0x0, 0x0, 0x7, 0xf, 0xf, 0xc3, 0x1f,
    0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x7, 0x8, 0xf, 0x2f, 0x4f, 0xe, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x7, 0x4f, 0xf, 0xa7, 0x87, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x10, 0x10,
    0xd3, 0x87, 0x97, 0xf, 0x2f, 0x7, 0x0, 0x0, 0x33, 0x10, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x8, 0x0, 0x0, 0x0, 0x8, 0xe, 0x8e, 0x1f, 0xf,
    0xc, 0x8, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x4f, 0x1f, 0xf, 0x4f, 0xe, 0x8, 0x0, 0x0,
    0x0, 0x0, 0x1, 0x3, 0x87, 0x87, 0x87, 0x47, 0x0, 0x0, 0x0, 0x10, 0x10, 0x30, 0x30, 0x10,
    0xef, 0x47, 0x7, 0x7, 0x3, 0x1, 0x0, 0x0, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x8, 0x8, 0xc, 0xc, 0xc, 0x0, 0x0, 0xe, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xc, 0xc, 0xc, 0x8, 0x8, 0x0, 0x0, 0x0, 0xf, 0xf, 0xf, 0xf, 0xf, 0xe, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x1, 0xf, 0xf, 0xf, 0xf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x2,
    0xf, 0xb, 0xc, 0xf, 0x1, 0x0, 0x0, 0x0, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0xc, 0x68, 0x68, 0x68, 0x6e, 0x6e, 0x0, 0x0, 0x3, 0xf, 0xf, 0xf, 0xf, 0xf,
    0x68, 0x68, 0x68, 0x68, 0x68, 0xc, 0x0, 0x0, 0xf, 0xf, 0x7, 0xc, 0xf, 0x3, 0x0, 0x0,
    0x0, 0x0, 0x7, 0xf, 0xf, 0xf, 0xf, 0xf, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x20,
    0x87, 0xf, 0xf, 0xf, 0xf, 0xf, 0x0, 0x0, 0x10, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x8, 0xc, 0xc, 0xc, 0x0, 0x0, 0xc, 0xf, 0xcf, 0x2f, 0xf, 0xf,
    0x8, 0xc, 0xc, 0x8, 0x0, 0x0, 0x0, 0x0, 0xf, 0xf, 0xf, 0xf, 0xf, 0xc, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x30, 0x52, 0x61, 0xf1, 0xbc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3,
    0xd2, 0x63, 0x52, 0x30, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x80, 0x48, 0x84, 0xc2, 0xe0, 0x0, 0x0, 0xe0, 0xb4, 0x7c, 0xe1, 0x5b, 0xa5,
    0x68, 0x84, 0xc0, 0x80, 0x0, 0x0, 0x0, 0x0, 0xf5, 0xe1, 0x5a, 0xbe, 0xe0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0xf, 0x33, 0x31, 0x71, 0xf3, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf0, 0xf3, 0x71, 0x31, 0x33, 0xf, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xc, 0x8e, 0xcf, 0x88,
    0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x88, 0xcf, 0x8e, 0xc, 0x8, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0xe0, 0xe0, 0xf1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x10, 0x20,
    0xe0, 0xf1, 0xe0, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x20, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88, 0xdd,
    0x22, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xff, 0xef, 0x67, 0x77, 0x33, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x11, 0x23, 0x67, 0x77, 0xff, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x79, 0x69, 0xf, 0x1f, 0xff, 0xff, 0x33, 0x0,
    0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x33, 0x79, 0x69, 0xf, 0x1f, 0xff, 0xff,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xcc, 0xcc, 0x88, 0x0, 0x88, 0xcc, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xcc, 0x88, 0x0, 0x88, 0xcc, 0xcc, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xff, 0xf0, 0xf0, 0xf7, 0x88, 0x0, 0x0, 0x0, 0x0, 0x33, 0x74, 0x74, 0xf8, 0xf9, 0xf9, 0xf9,
    0x0, 0x0, 0x0, 0x88, 0xf7, 0xf0, 0xf0, 0xff, 0xf9, 0xf9, 0xf9, 0xf8, 0x74, 0x74, 0x33, 0x0,
    0xff, 0xf0, 0xf0, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xf0, 0xf0, 0xff, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0xff, 0xf0, 0xf0, 0xff, 0x0, 0x0, 0x0, 0x0, 0xff, 0xf0, 0xf0, 0xff,
    0x0, 0xcc, 0xe2, 0xe2, 0xf1, 0xf9, 0xf9, 0xf9, 0xff, 0xf0, 0xf0, 0xfe, 0x11, 0x0, 0x0, 0x0,
    0xf9, 0xf9, 0xf9, 0xf1, 0xe2, 0xe2, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x11, 0xfe, 0xf0, 0xf0, 0xff,
    0xff, 0xf0, 0xf0, 0xf0, 0xf0, 0xf8, 0xf8, 0xf8, 0xff, 0xf0, 0xf0, 0xfe, 0x11, 0x0, 0x0, 0x0,
    0xf8, 0xf8, 0xf8, 0xf0, 0xf0, 0xf0, 0xf0, 0xff, 0x0, 0x0, 0x0, 0x11, 0xfe, 0xf0, 0xf0, 0xff,
    0xff, 0xf0, 0xf0, 0xf7, 0x88, 0x0, 0x0, 0x0, 0xff, 0xf0, 0xf0, 0xf0, 0xf0, 0xf1, 0xf1, 0xf1,
    0x0, 0x0, 0x0, 0x88, 0xf7, 0xf0, 0xf0, 0xff, 0xf1, 0xf1, 0xf1, 0xf0, 0xf0, 0xf0, 0xf0, 0xff,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9,
    0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xcc, 0xe2, 0xe2, 0xf1, 0xf1, 0xf1, 0xf1,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf1, 0xf1, 0xf1, 0xf1, 0xe2, 0xe2, 0xcc, 0x0,
    0x0, 0x33, 0x74, 0x74, 0xf8, 0xf8, 0xf8, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf8, 0xf8, 0xf8, 0xf8, 0x74, 0x74, 0x33, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1, 0xf1,
    0x0, 0x0, 0x0, 0x0, 0x33, 0x74, 0xf8, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf8, 0xf8, 0x74, 0x33, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0xff, 0xf0, 0xf0, 0xf0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xf0, 0xf0, 0xf0,
    0xf0, 0xf0, 0xf0, 0xff, 0x0, 0x0, 0x0, 0x0, 0xf0, 0xf0, 0xf0, 0xff, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xcc, 0xe2, 0xf1, 0xf1,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf1, 0xf1, 0xe2, 0xcc, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0xff, 0xf8, 0xf8, 0xf9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf9, 0xf8, 0xf8, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xf1, 0xf1, 0xf9,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf9, 0xf1, 0xf1, 0xff, 0x0, 0x0, 0x0, 0x0,
    0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xff, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0xf9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x88, 0xf7, 0xf0, 0xf0, 0xf0, 0xf1, 0xf1, 0xf1, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0,
    0xf0, 0xf0, 0xf0, 0xf7, 0x88, 0x0, 0x0, 0x0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf1, 0xf1, 0xf1,
    0xf8, 0xf8, 0xf8, 0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0x0, 0x0, 0x0, 0x11, 0xfe, 0xf0, 0xf0, 0xf0,
    0xf0, 0xf0, 0xf0, 0xf0, 0xf0, 0xf8, 0xf8, 0xf8, 0xf0, 0xf0, 0xf0, 0xfe, 0x11, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x33, 0x74, 0xf8, 0xf8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf8, 0xf8, 0x74, 0x33, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xcc, 0xe2, 0xf1, 0xf1,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf1, 0xf1, 0xe2, 0xcc, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x88, 0xf7, 0xf0, 0xf0, 0xf0, 0xf9, 0xf9, 0xf9, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8,
    0xf0, 0xf0, 0xf0, 0xf7, 0x88, 0x0, 0x0, 0x0, 0xf8, 0xf8, 0xf8, 0xf8, 0xf8, 0xf9, 0xf9, 0xf9,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};

static uint8_t rom_sprites[4096] = {
    0x0, 0x0, 0x0, 0x8, 0xc, 0xc, 0x8c, 0xc, 0x0, 0x0, 0x30, 0x30, 0x10, 0x10, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0xc0, 0x20, 0x90, 0x80, 0x0, 0x0, 0x0, 0x7, 0xf, 0xf, 0xc3, 0x1f,
    0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x41, 0x21, 0x12, 0x3, 0x3, 0x1, 0x0, 0x0, 0x7, 0x8, 0xf, 0x2f, 0x4f, 0xe, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x10, 0x10,
    0x0, 0x0, 0x0, 0x7, 0x4f, 0xf, 0xa7, 0x87, 0x0, 0x0, 0x0, 0x8, 0xe, 0x8e, 0x1f, 0xf,
    0xc, 0x8, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x33, 0x10, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0,
    0xd3, 0x87, 0x97, 0xf, 0x2f, 0x7, 0x0, 0x0, 0x4f, 0x1f, 0xf, 0x4f, 0xe, 0x8, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x8, 0x8, 0xc, 0xc, 0xc, 0x0, 0x0, 0x0, 0x10, 0x10, 0x30, 0x30, 0x10,
    0x0, 0x0, 0x1, 0x3, 0x87, 0x87, 0x87, 0x47, 0x0, 0x0, 0xe, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xc, 0xc, 0xc, 0x8, 0x8, 0x0, 0x0, 0x0, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xef, 0x47, 0x7, 0x7, 0x3, 0x1, 0x0, 0x0, 0xf, 0xf, 0xf, 0xf, 0xf, 0xe, 0x0, 0x0,
    0x0, 0x0, 0xc, 0x68, 0x68, 0x68, 0x6e, 0x6e, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x2,
    0x0, 0x0, 0x0, 0x1, 0xf, 0xf, 0xf, 0xf, 0x0, 0x0, 0x3, 0xf, 0xf, 0xf, 0xf, 0xf,
    0x68, 0x68, 0x68, 0x68, 0x68, 0xc, 0x0, 0x0, 0x2, 0x1, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf, 0xb, 0xc, 0xf, 0x1, 0x0, 0x0, 0x0, 0xf, 0xf, 0x7, 0xc, 0xf, 0x3, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x8, 0xc, 0xc, 0xc, 0x0, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x20,
    0x0, 0x0, 0x7, 0xf, 0xf, 0xf, 0xf, 0xf, 0x0, 0x0, 0xc, 0xf, 0xcf, 0x2f, 0xf, 0xf,
    0x8, 0xc, 0xc, 0x8, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x1, 0x1, 0x1, 0x0, 0x0, 0x0,
    0x87, 0xf, 0xf, 0xf, 0xf, 0xf, 0x0, 0x0, 0xf, 0xf, 0xf, 0xf, 0xf, 0xc, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x80, 0x48, 0x84, 0xc2, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x3,
    0x0, 0x0, 0x0, 0x30, 0x52, 0x61, 0xf1, 0xbc, 0x0, 0x0, 0xe0, 0xb4, 0x7c, 0xe1, 0x5b, 0xa5,
    0x68, 0x84, 0xc0, 0x80, 0x0, 0x0, 0x0, 0x0, 0x2, 0x2, 0x4, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xd2, 0x63, 0x52, 0x30, 0x0, 0x0, 0x0, 0x0, 0xf5, 0xe1, 0x5a, 0xbe, 0xe0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0xf, 0x33, 0x31, 0x71, 0xf3, 0x0, 0x0, 0x0, 0x8, 0xc, 0x8e, 0xcf, 0x88,
    0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf0, 0xf3, 0x71, 0x31, 0x33, 0xf, 0x0, 0x0, 0xff, 0x88, 0xcf, 0x8e, 0xc, 0x8, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10, 0x10, 0x20,
    0x0, 0x0, 0x0, 0x0, 0x0, 0xe0, 0xe0, 0xf1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88, 0xdd,
    0x22, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20, 0x20, 0x10, 0x10, 0x0, 0x0, 0x0, 0x0,
    0xe0, 0xf1, 0xe0, 0xe0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0xee, 0xcc, 0x88, 0x8c, 0x4e, 0xee, 0x88, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77, 0x77,
    0x0, 0x11, 0xff, 0xff, 0x8f, 0xf, 0x3c, 0xbc, 0x0, 0x7f, 0xbf, 0x7f, 0xaf, 0x5f, 0x7f, 0xff,
    0x88, 0xee, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0x0, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0, 0x0,
    0xff, 0xff, 0x8f, 0xf, 0x3c, 0xbc, 0x11, 0x0, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xff, 0xff, 0x0,
    0x0, 0xcc, 0xee, 0xee, 0x8c, 0x8, 0xcc, 0xee, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77, 0x77,
    0x0, 0x11, 0xff, 0xff, 0x8f, 0xf, 0x3c, 0xbc, 0x0, 0x7f, 0xbf, 0x7f, 0xaf, 0x5f, 0x7f, 0xff,
    0xee, 0xcc, 0x88, 0xcc, 0xee, 0xee, 0xcc, 0x0, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0, 0x0,
    0xff, 0xff, 0x8f, 0xf, 0x3c, 0xbc, 0x11, 0x0, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xff, 0xff, 0x0,
    0x0, 0x0, 0x0, 0xee, 0xee, 0xee, 0xcc, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x60, 0x69, 0xf, 0x71, 0x69, 0xf, 0x17, 0x0, 0x0, 0x0, 0x88, 0xee, 0xff, 0xff, 0xff,
    0xcc, 0xcc, 0xcc, 0xee, 0xee, 0xee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0x77, 0x33, 0x0, 0x0, 0x0,
    0x0, 0xee, 0xee, 0xee, 0xcc, 0xcc, 0xcc, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x60, 0x69, 0xf, 0x71, 0x69, 0xf, 0x17, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xcc, 0xcc, 0xee, 0xee, 0xee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x77, 0x33, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x44, 0xee, 0xee, 0xee, 0xee, 0xee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x11, 0x11, 0x0,
    0xee, 0x66, 0x66, 0xee, 0xee, 0xee, 0x66, 0x22, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x44, 0xee, 0xee, 0xee, 0xee, 0x66, 0x66, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x66, 0x66, 0x66, 0x66, 0xee, 0xee, 0x66, 0x22, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x8, 0xc, 0xe, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x7, 0x7, 0x7, 0x3,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x3, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf, 0xf, 0xf, 0x7, 0x3, 0x1, 0x0, 0x0, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x7, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3, 0x7, 0x7, 0x7, 0xf, 0xf, 0xf, 0xf,
    0x0, 0x8, 0xc, 0xe, 0xf, 0xf, 0xf, 0xf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xc, 0xe,
    0xf, 0xf, 0xf, 0xf, 0xe, 0xe, 0xe, 0xc, 0x0, 0x1, 0x3, 0x7, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xc, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xe, 0x0, 0xf, 0xf, 0xf, 0xe, 0xc, 0x8, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xc, 0xe, 0xe, 0xe, 0xf, 0xf, 0xf, 0xf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x3, 0x7, 0x0, 0x1, 0x3, 0x7, 0xf, 0xf, 0xf, 0xf,
    0xe, 0xe, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x7, 0x7, 0x7, 0x3,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x3, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf, 0xf, 0xf, 0x7, 0x3, 0x1, 0x0, 0x0, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x7, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x3,
    0x0, 0x0, 0x1, 0x3, 0x7, 0xf, 0xf, 0xf, 0x0, 0x0, 0x8, 0x8, 0xc, 0xc, 0xe, 0xe,
    0x0, 0x0, 0x0, 0x8, 0x8, 0x8, 0xc, 0xc, 0x3, 0x7, 0x7, 0x7, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xe, 0xe, 0xe, 0xc, 0x7, 0x7, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xc, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xe, 0x0, 0xf, 0xf, 0xf, 0xe, 0xc, 0x8, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x1, 0x1, 0x3, 0x3, 0x7, 0x7, 0x0, 0x0, 0x8, 0xc, 0xe, 0xf, 0xf, 0xf,
    0xc, 0xe, 0xe, 0xe, 0xf, 0xf, 0xf, 0xf, 0x0, 0x0, 0x0, 0x1, 0x1, 0x1, 0x3, 0x3,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x7, 0x7, 0x7, 0x3,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x3, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xf, 0xf, 0xf, 0x7, 0x3, 0x1, 0x0, 0x0, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x7, 0x0,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x1, 0x3,
    0x0, 0x0, 0x1, 0x3, 0x7, 0xf, 0xf, 0xf, 0x0, 0x7, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x3, 0x7, 0x7, 0x7, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xe, 0xe, 0xe, 0xc, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xc, 0x8, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xe, 0x0, 0xf, 0xf, 0xf, 0xe, 0xc, 0x8, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x8, 0xc, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0x0, 0xe, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0x0, 0x0, 0x8, 0xc, 0xe, 0xf, 0xf, 0xf,
    0xc, 0xe, 0xe, 0xe, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf, 0xf,
    0x0, 0xe0, 0xc0, 0x80, 0xc0, 0xe0, 0xe0, 0x80, 0x0, 0x0, 0x0, 0x10, 0x30, 0x30, 0x70, 0x70,
    0x0, 0x10, 0xf0, 0xf0, 0xf0, 0xf3, 0xf3, 0xf0, 0x0, 0xf0, 0xf1, 0xf2, 0xf2, 0xf1, 0xf1, 0xf2,
    0x80, 0xe0, 0xe0, 0xc0, 0x80, 0xc0, 0xe0, 0x0, 0x70, 0x70, 0x30, 0x30, 0x10, 0x0, 0x0, 0x0,
    0xf0, 0xf3, 0xf3, 0xf0, 0xf0, 0xf0, 0x10, 0x0, 0xf2, 0xf1, 0xf1, 0xf2, 0xf2, 0xf1, 0xf0, 0x0,
    0x0, 0xc0, 0xe0, 0xe0, 0xc0, 0x80, 0xc0, 0xe0, 0x0, 0x0, 0x0, 0x10, 0x30, 0x30, 0x70, 0x70,
    0x0, 0x10, 0xf0, 0xf0, 0xf0, 0xf3, 0xf3, 0xf0, 0x0, 0xf0, 0xf1, 0xf2, 0xf2, 0xf1, 0xf1, 0xf2,
    0xe0, 0xc0, 0x80, 0xc0, 0xe0, 0xe0, 0xc0, 0x0, 0x70, 0x70, 0x30, 0x30, 0x10, 0x0, 0x0, 0x0,
    0xf0, 0xf3, 0xf3, 0xf0, 0xf0, 0xf0, 0x10, 0x0, 0xf2, 0xf1, 0xf1, 0xf2, 0xf2, 0xf1, 0xf0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0xee, 0x88, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77, 0x77,
    0x0, 0x11, 0xbc, 0x3c, 0xf, 0x8f, 0xff, 0xff, 0x0, 0xff, 0xff, 0x7f, 0x7f, 0xff, 0xff, 0xff,
    0x88, 0xee, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0x0, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0, 0x0,
    0xbc, 0x3c, 0xf, 0x8f, 0xff, 0xff, 0x11, 0x0, 0xff, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x0,
    0x0, 0xcc, 0xee, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77, 0x77,
    0x0, 0x11, 0xbc, 0x3c, 0xf, 0x8f, 0xff, 0xff, 0x0, 0xff, 0xff, 0x7f, 0x7f, 0xff, 0xff, 0xff,
    0xee, 0xcc, 0x88, 0xcc, 0xee, 0xee, 0xcc, 0x0, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0, 0x0,
    0xbc, 0x3c, 0xf, 0x8f, 0xff, 0xff, 0x11, 0x0, 0xff, 0x7f, 0x7f, 0xff, 0xff, 0xff, 0xff, 0x0,
    0x0, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0xee, 0x88, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77, 0x77,
    0x0, 0x11, 0xff, 0xcf, 0x8f, 0x8f, 0xcf, 0xff, 0x0, 0xff, 0xff, 0x7f, 0xf3, 0xf3, 0x7f, 0xff,
    0x88, 0xee, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0x0, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0, 0x0,
    0xff, 0xcf, 0x8f, 0x8f, 0xcf, 0xff, 0x11, 0x0, 0xff, 0x7f, 0xf3, 0xf3, 0x7f, 0xff, 0xff, 0x0,
    0x0, 0xcc, 0xee, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77, 0x77,
    0x0, 0x11, 0xff, 0xcf, 0x8f, 0x8f, 0xcf, 0xff, 0x0, 0xff, 0xff, 0x7f, 0xf3, 0xf3, 0x7f, 0xff,
    0xee, 0xcc, 0x88, 0xcc, 0xee, 0xee, 0xcc, 0x0, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0, 0x0,
    0xff, 0xcf, 0x8f, 0x8f, 0xcf, 0xff, 0x11, 0x0, 0xff, 0x7f, 0xf3, 0xf3, 0x7f, 0xff, 0xff, 0x0,
    0x0, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0xee, 0x88, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77, 0x77,
    0x0, 0x11, 0xff, 0xff, 0x8f, 0xf, 0x3c, 0xbc, 0x0, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xff,
    0x88, 0xee, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0x0, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0, 0x0,
    0xff, 0xff, 0x8f, 0xf, 0x3c, 0xbc, 0x11, 0x0, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xff, 0xff, 0x0,
    0x0, 0xcc, 0xee, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77, 0x77,
    0x0, 0x11, 0xff, 0xff, 0x8f, 0xf, 0x3c, 0xbc, 0x0, 0xff, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xff,
    0xee, 0xcc, 0x88, 0xcc, 0xee, 0xee, 0xcc, 0x0, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0, 0x0,
    0xff, 0xff, 0x8f, 0xf, 0x3c, 0xbc, 0x11, 0x0, 0xff, 0xff, 0xff, 0x7f, 0x7f, 0xff, 0xff, 0x0,
    0x0, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0xee, 0x88, 0x0, 0x0, 0x0, 0x1, 0x30, 0x30, 0x67, 0x77,
    0x0, 0x11, 0xff, 0x3f, 0x1f, 0x1f, 0x3f, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x88, 0xee, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0x0, 0x77, 0x67, 0x30, 0x30, 0x1, 0x0, 0x0, 0x0,
    0xff, 0x3f, 0x1f, 0x1f, 0x3f, 0xff, 0x11, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
    0x0, 0xcc, 0xee, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0x0, 0x0, 0x0, 0x1, 0x30, 0x30, 0x67, 0x77,
    0x0, 0x11, 0xff, 0x3f, 0x1f, 0x1f, 0x3f, 0xff, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xee, 0xcc, 0x88, 0xcc, 0xee, 0xee, 0xcc, 0x0, 0x77, 0x67, 0x30, 0x30, 0x1, 0x0, 0x0, 0x0,
    0xff, 0x3f, 0x1f, 0x1f, 0x3f, 0xff, 0x11, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x7, 0x8, 0x8, 0x7, 0x0, 0x7, 0x8, 0x0, 0xc, 0x2, 0x2, 0xc, 0x0, 0xc, 0x2,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x8, 0x7, 0x0, 0x6, 0x9, 0x8, 0x8, 0x6, 0x2, 0xc, 0x0, 0x2, 0x2, 0xa, 0x6, 0x2,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x7, 0x8, 0x8, 0x7, 0x0, 0x7, 0x8, 0x0, 0xc, 0x2, 0x2, 0xc, 0x0, 0xc, 0x2,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x8, 0x7, 0x0, 0x0, 0xf, 0x4, 0x2, 0x1, 0x2, 0xc, 0x0, 0x8, 0xe, 0x8, 0x8, 0x8,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x7, 0x8, 0x8, 0x7, 0x0, 0x7, 0x8, 0x0, 0xc, 0x2, 0x2, 0xc, 0x0, 0xc, 0x2,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x8, 0x7, 0x0, 0x6, 0x9, 0x9, 0x9, 0x6, 0x2, 0xc, 0x0, 0xc, 0x2, 0x2, 0x2, 0xc,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x7, 0x8, 0x8, 0x7, 0x0, 0x7, 0x8, 0x8, 0xc, 0x2, 0x2, 0xc, 0x0, 0xc, 0x2, 0x2,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x7, 0x0, 0x9, 0x9, 0x9, 0x7, 0x0, 0xf, 0xc, 0x0, 0xc, 0x2, 0x2, 0xc, 0x0, 0xe,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xcc, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x66, 0x77,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11,
    0xcc, 0xcc, 0xcc, 0x88, 0x88, 0x0, 0x0, 0x0, 0x77, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0,
    0x88, 0xcc, 0xee, 0xff, 0xff, 0xff, 0x77, 0x0, 0x33, 0x77, 0xff, 0xff, 0xff, 0xff, 0xcc, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77, 0x77,
    0x0, 0x0, 0x77, 0xff, 0xff, 0xff, 0xee, 0xcc, 0x0, 0x0, 0xcc, 0xcc, 0x88, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x77, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0,
    0x88, 0xcc, 0xee, 0xff, 0xff, 0xff, 0x77, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88, 0xcc, 0xcc, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x88, 0x88, 0xcc, 0xcc, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77, 0x77,
    0x0, 0x0, 0x0, 0x88, 0x88, 0xcc, 0xcc, 0xcc, 0x0, 0x0, 0x0, 0x33, 0x33, 0x77, 0x77, 0x77,
    0xcc, 0xcc, 0xcc, 0x88, 0x88, 0x0, 0x0, 0x0, 0x77, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0,
    0xee, 0xee, 0xee, 0xff, 0xff, 0xff, 0x77, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcc, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x88, 0x88, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77, 0x77,
    0x0, 0x0, 0x77, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0xcc, 0xff, 0xff, 0xff, 0xee, 0x0,
    0x0, 0x0, 0x0, 0x88, 0x88, 0x0, 0x0, 0x0, 0x77, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0,
    0xcc, 0xff, 0xff, 0xff, 0xff, 0xff, 0x77, 0x0, 0x0, 0x0, 0xee, 0xff, 0xff, 0xff, 0xcc, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x88, 0x88, 0xcc, 0xcc, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77, 0x77,
    0x0, 0x0, 0x77, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0, 0x0, 0xcc, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xcc, 0xcc, 0xcc, 0x88, 0x88, 0x0, 0x0, 0x0, 0x77, 0x77, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x77, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xcc, 0x0,
    0x1, 0x2, 0x4, 0xc, 0x8, 0x84, 0x84, 0x8, 0x1, 0x0, 0x0, 0x0, 0x9, 0x5, 0x3, 0x0,
    0x0, 0x8, 0x7, 0x78, 0xfa, 0xf5, 0xea, 0x7b, 0x0, 0x0, 0x0, 0xb, 0xb5, 0xea, 0x77, 0x32,
    0x8, 0x84, 0x84, 0x8, 0xc, 0x4, 0x2, 0x1, 0x0, 0x1, 0x1, 0x1, 0x3, 0x4, 0x8, 0x0,
    0x26, 0x5d, 0xb2, 0x7c, 0x7, 0x0, 0x0, 0x0, 0x72, 0xe6, 0xcc, 0xfc, 0xe3, 0xe, 0x0, 0x0,
    0x0, 0x60, 0x60, 0xe0, 0xe0, 0xe8, 0xcc, 0x88, 0x0, 0x0, 0x0, 0x1, 0x0, 0x0, 0x67, 0x77,
    0x0, 0x11, 0xff, 0x3f, 0x1f, 0x1f, 0x3f, 0xff, 0x0, 0x0, 0xf0, 0xf8, 0xfd, 0xff, 0xff, 0xff,
    0x88, 0xee, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0x0, 0x77, 0x67, 0x0, 0x0, 0x1, 0x0, 0x0, 0x0,
    0xff, 0x3f, 0x1f, 0x1f, 0x3f, 0xff, 0x11, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
    0x0, 0x60, 0x60, 0xe0, 0xe0, 0xe8, 0xcc, 0x88, 0x0, 0x0, 0x0, 0x11, 0x23, 0x23, 0x77, 0x77,
    0x0, 0x11, 0xff, 0x1d, 0xc, 0xf, 0x1f, 0xff, 0x0, 0x0, 0xf0, 0xf8, 0xfd, 0xff, 0xff, 0xff,
    0x88, 0xee, 0xee, 0xcc, 0x88, 0xcc, 0xee, 0x0, 0x77, 0x77, 0x23, 0x23, 0x11, 0x0, 0x0, 0x0,
    0xff, 0x1d, 0xc, 0xf, 0x1f, 0xff, 0x11, 0x0, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x11, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0xff, 0xff, 0xff, 0x77, 0x33, 0x11, 0x0, 0x0, 0x0, 0xcc, 0xee, 0xee, 0xff, 0xff,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x11, 0x0,
    0x0, 0x11, 0x33, 0x77, 0xff, 0xff, 0xff, 0x0, 0xff, 0xff, 0xff, 0xee, 0xee, 0xcc, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x77, 0xff, 0x77, 0x77, 0x33, 0x11, 0x11, 0x0, 0x0, 0xcc, 0xee, 0xee, 0xff, 0xff, 0xff,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x11, 0x11, 0x33, 0x77, 0x77, 0xff, 0x77, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xcc, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x33, 0x33, 0x33, 0x11, 0x11, 0x11, 0x0, 0x0, 0x88, 0xcc, 0xee, 0xee, 0xff, 0xff, 0xff,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x11, 0x11, 0x11, 0x33, 0x33, 0x33, 0xee, 0xff, 0xff, 0xff, 0xee, 0xee, 0xcc, 0x88,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x11, 0x11, 0x11, 0x11, 0x0, 0x0, 0x0, 0x0, 0xcc, 0xee, 0xee, 0xff, 0xff, 0xff, 0xff,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x11, 0x11, 0x11, 0x11, 0xee, 0xff, 0xff, 0xff, 0xff, 0xee, 0xee, 0xcc,
    0x0, 0x0, 0x0, 0x0, 0x88, 0x88, 0x88, 0x88, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x66, 0x77, 0x77, 0x77, 0xff, 0xff, 0xff,
    0x0, 0x88, 0x88, 0x88, 0x88, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0xff, 0xff, 0x77, 0x77, 0x77, 0x66,
    0x0, 0x0, 0x88, 0x88, 0xcc, 0xcc, 0xcc, 0x88, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x33, 0x77, 0x77, 0xff,
    0x0, 0x88, 0xcc, 0xcc, 0xcc, 0x88, 0x88, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0xff, 0x77, 0x77, 0x33, 0x33, 0x33, 0x11,
    0x0, 0x0, 0xcc, 0xee, 0xee, 0xee, 0xee, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x11, 0x33, 0x33, 0x77,
    0x88, 0xcc, 0xee, 0xee, 0xee, 0xee, 0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x77, 0x33, 0x33, 0x11, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x44, 0xee, 0xee, 0xee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x33, 0x77,
    0xcc, 0xee, 0xee, 0xee, 0x44, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x77, 0x33, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x44, 0xee, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x33,
    0xcc, 0xee, 0x44, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x33, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0xcc, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xff, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x22, 0x44, 0x11, 0x22, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x22, 0x11, 0x0, 0x0, 0x0, 0x11, 0x99, 0x44, 0x0, 0x0,
    0x0, 0x22, 0x11, 0x88, 0x44, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x11, 0x22, 0x0, 0x11, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x88, 0x22, 0x22, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};


static uint8_t rom_hwcolors[32] = {
    0x0, 0x7, 0x66, 0xef, 0x0, 0xf8, 0xea, 0x6f, 0x0, 0x3f, 0x0, 0xc9, 0x38, 0xaa, 0xaf, 0xf6,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};

static uint8_t rom_palette[256] = {
    0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xb, 0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xb, 0x3,
    0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xb, 0x5, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xb, 0x7,
    0x0, 0x0, 0x0, 0x0, 0x0, 0xb, 0x1, 0x9, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0x0, 0xe, 0x0, 0x1, 0xc, 0xf,
    0x0, 0xe, 0x0, 0xb, 0x0, 0xc, 0xb, 0xe, 0x0, 0xc, 0xf, 0x1, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x1, 0x2, 0xf, 0x0, 0x7, 0xc, 0x2, 0x0, 0x9, 0x6, 0xf, 0x0, 0xd, 0xc, 0xf,
    0x0, 0x5, 0x3, 0x9, 0x0, 0xf, 0xb, 0x0, 0x0, 0xe, 0x0, 0xb, 0x0, 0xe, 0x0, 0xb,
    0x0, 0x0, 0x0, 0x0, 0x0, 0xf, 0xe, 0x1, 0x0, 0xf, 0xb, 0xe, 0x0, 0xe, 0x0, 0xf,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
    0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,
};
